/*! For license information please see lib-face-landmarks-detection.b916f2f032c429789793.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{71:function(t,e,a){"use strict";(function(t){a.d(e,"a",(function(){return Qt})),a.d(e,"b",(function(){return Xt}));a(35),a(8),a(5);var n,s,r=a(0),o=a(2);!function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(n||(n={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(s||(s={}));const i={};function p(t){return i[t]}function m(t,e,a,n,s){const o=e.inputParams[t];if(o&&void 0!==o.inputIndexStart){const t=o.inputIndexStart,i=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?t+1:o.inputIndexEnd;if("tensor"===o.type)return u(e.inputNames[o.inputIndexStart],a,n,s);if("tensors"===o.type){return e.inputNames.slice(t,i).map((t=>u(t,a,n,s)))}const p=u(e.inputNames.slice(t)[0],a,n,s),m=p.dataSync();return"number"===o.type?m[0]:Object(r.yh)(p.shape,m)}const i=e.attrParams[t];return i&&i.value}function u(t,e,a,n){const[s,r]=l(t);if(null!=n){const t=n.getHashTableHandleByName(s);if(null!=t)return t}const o=a.currentContextIds.find((t=>!!e[d(s,t)]));return void 0!==o?e[d(s,o)][r]:void 0}function c(t,e){const[a,n]=l(t);return[d(a,e&&e.currentContextId),n]}function d(t,e){return e?`${t}-${e}`:t}function l(t){const e=t.split(":");if(1===e.length)return[t,0];return[e[0],Number(e[e.length-1])]}function y(t,e,a){let n=m("pad",t,e,a);if("explicit"===n){n=m("explicitPaddings",t,e,a);const s=[[0,0],[0,0],[0,0],[0,0]];for(let t=0;t<4;t++)s[t][0]=n[2*t],s[t][1]=n[2*t+1];return s}return n}function h(t){return t.kept?t:Object(r.cd)(t)}var f=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var b=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var g=Object.freeze({__proto__:null,json:[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}]});var N=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var O=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var x=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var T=Object.freeze({__proto__:null,json:[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});var w=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var _=Object.freeze({__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]}]});var S=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}]});var j=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var v=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var E=Object.freeze({__proto__:null,json:[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]});var M=Object.freeze({__proto__:null,json:[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var I=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]});var A=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var D=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}]});class k{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[f,b,g,N,O,x,T,j,S,w,v,E,M,I,A,D,_].map((t=>t.json)));this.opMappers=t.reduce(((t,e)=>(t[e.tfOpName]=e,t)),{})}transformGraph(t,e={}){const a=t.node,n=[],s=[],r=[],o=a.reduce(((t,e)=>(t[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")?n.push(t[e.name]):"Const"===e.op?s.push(t[e.name]):null!=e.input&&0!==e.input.length||r.push(t[e.name]),t)),{});let i=[];const p=[];let m={},u={};null!=e&&(m=this.mapSignatureEntries(e.inputs),u=this.mapSignatureEntries(e.outputs));const d=Object.keys(o);d.forEach((t=>{const e=o[t];e.inputNames.forEach((t=>{const[a]=c(t);e.inputs.push(o[a]),o[a].children.push(e)}))})),0===Object.keys(u).length?d.forEach((t=>{const e=o[t];0===e.children.length&&p.push(e)})):Object.keys(u).forEach((t=>{const[e]=c(t),a=o[e];null!=a&&(a.signatureKey=u[t],p.push(a))})),Object.keys(m).length>0?Object.keys(m).forEach((t=>{const[e]=c(t),a=o[e];a&&(a.signatureKey=m[t],i.push(a))})):i=n;let l={};null!=t.library&&null!=t.library.function&&(l=t.library.function.reduce(((t,e)=>(t[e.signature.name]=this.mapFunction(e),t)),{}));const y={nodes:o,inputs:i,outputs:p,weights:s,placeholders:n,signature:e,functions:l};return r.length>0&&(y.initNodes=r),y}mapSignatureEntries(t){return Object.keys(t||{}).reduce(((e,a)=>(e[t[a].name]=a,e)),{})}mapNode(t){const e=p(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const a={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map((t=>t.startsWith("^")?t.substr(1):t)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr};return null!=e.inputs&&(a.inputParams=e.inputs.reduce(((t,e)=>(t[e.name]={type:e.type,inputIndexStart:e.start,inputIndexEnd:e.end},t)),{})),null!=e.attrs&&(a.attrParams=e.attrs.reduce(((e,a)=>{const n=a.type;let s;switch(a.type){case"string":s=V(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=V(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":s=W(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=W(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":s=P(t.attr,a.tfName,a.defaultValue||0),void 0===s&&a.tfDeprecatedName&&(s=P(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":s=U(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=U(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":s=C(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=C(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":s=G(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=G(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":s=H(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=H(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":s=q(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=q(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":s=$(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=$(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":s=R(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=R(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":s=F(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=F(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${t.op}`)}return e[a.name]={value:s,type:n},e}),{})),a}mapFunction(t){const e=t.nodeDef,a=[];let n={};null!=e&&(n=e.reduce(((t,e)=>(t[e.name]=this.mapNode(e),"Const"===e.op&&a.push(t[e.name]),t)),{}));const s=[],r=[];t.signature.inputArg.forEach((t=>{const[e]=c(t.name),a={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:z(t.type),type:"dtype"}},children:[]};a.signatureKey=t.name,s.push(a),n[e]=a}));Object.keys(n).forEach((t=>{const e=n[t];e.inputNames.forEach((t=>{const[a]=c(t);e.inputs.push(n[a]),n[a].children.push(e)}))}));const o=t.ret;t.signature.outputArg.forEach((t=>{const[e,a]=c(o[t.name]),s=n[e];null!=s&&(s.defaultOutput=a,r.push(s))}));const i=this.mapArgsToSignature(t);return{nodes:n,inputs:s,outputs:r,weights:a,placeholders:[],signature:i}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce(((t,e)=>(t[e.name]=this.mapArgToTensorInfo(e),t)),{}),outputs:t.signature.outputArg.reduce(((e,a)=>(e[a.name]=this.mapArgToTensorInfo(a,t.ret),e)),{})}}mapArgToTensorInfo(t,e){let a=t.name;return null!=e&&(a=e[a]),{name:a,dtype:t.type}}}function L(e,a){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const a=Object(r.Bf)().global;if(void 0!==a.atob)return a.atob(e);if(void 0!==t)return new t(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return a?n:n.toLowerCase()}function V(t,e,a,n=!1){const s=t[e];return null!=s?L(s.s,n):a}function C(t,e,a){const n=t[e];return n?n.b:a}function P(t,e,a){const n=t[e]||{},s=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof s?s:parseInt(s,10)}function z(t){switch("string"==typeof t&&(t=n[t]),t){case n.DT_FLOAT:return"float32";case n.DT_INT32:case n.DT_INT64:case n.DT_INT8:case n.DT_UINT8:return"int32";case n.DT_BOOL:return"bool";case n.DT_DOUBLE:return"float32";case n.DT_STRING:return"string";default:return null}}function F(t,e,a){const n=t[e];return n&&n.func?n.func.name:a}function $(t,e,a){const n=t[e];return n&&n.type?z(n.type):a}function R(t,e,a){const n=t[e];return n&&n.list&&n.list.type?n.list.type.map((t=>z(t))):a}function B(t){if(!t.unknownRank)return null!=t.dim?t.dim.map((t=>"number"==typeof t.size?t.size:parseInt(t.size,10))):[]}function H(t,e,a){const n=t[e];return n&&n.shape?B(n.shape):a}function U(t,e,a){const n=t[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map((t=>"number"==typeof t?t:parseInt(t,10))):a}function W(t,e,a,n=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map((t=>L(t,n))):a}function q(t,e,a){const n=t[e];return n&&n.list&&n.list.shape?n.list.shape.map((t=>B(t))):a}function G(t,e,a){const n=t[e];return n&&n.list&&n.list.b?n.list.b:a}class K{constructor(t,e,a){this.node=t,this.tensorMap=e,this.context=a,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map((t=>this.getInput(t))),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce(((t,e)=>(t[e]=this.getAttr(e),t)),{}))}getInput(t){return u(t,this.tensorMap,this.context)}getAttr(t,e){const a=this.node.rawAttrs[t];if(null!=a.tensor)return u(t,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return P(this.node.rawAttrs,t,e);if(null!=a.s)return V(this.node.rawAttrs,t,e);if(null!=a.b)return C(this.node.rawAttrs,t,e);if(null!=a.shape)return H(this.node.rawAttrs,t,e);if(null!=a.type)return $(this.node.rawAttrs,t,e);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return U(this.node.rawAttrs,t,e);if(null!=a.list.s)return W(this.node.rawAttrs,t,e);if(null!=a.list.shape)return q(this.node.rawAttrs,t,e);if(null!=a.list.b)return G(this.node.rawAttrs,t,e);if(null!=a.list.type)return R(this.node.rawAttrs,t,e)}return e}}function Q(t,e,a=""){Object(r.F)(function(t,e){if(t.length!==e.length)return!1;for(let a=0;a<t.length;a++)if(-1!==t[a]&&-1!==e[a]&&t[a]!==e[a])return!1;return!0}(t,e),(()=>a+` Shapes ${t} and ${e} must match`))}class J{constructor(t,e,a,n,s,o,i){this.name=t,this.dtype=e,this.maxSize=a,this.elementShape=n,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Object(r.G)(0),Object(r.H)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.tensor.id)||e.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map((t=>this.read(t)))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),Q(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);a.tensor=e,Object(r.H)(e),a.written=!0,this.tensors[t]=a}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach(((t,a)=>this.write(t,e[a])))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return Object(r.I)([],[0].concat(this.elementShape));const a=this.readMany(t);return Q(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),Object(r.J)(a,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return Object(r.I)([],[0].concat(this.elementShape));const e=[];for(let t=0;t<this.size();t++)e.push(t);const a=this.readMany(e);return Q(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),Object(r.K)(a,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const a=Math.max(...t);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(t,Object(r.L)(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let a=0;const n=t.map((t=>(a+=t,a)));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===a?0:e.size/a,o=[];Object(r.M)((()=>{e=Object(r.N)(e,[1,a,s]);for(let a=0;a<t.length;++a){const i=[0,0===a?0:n[a-1],0],p=[1,t[a],s];o[a]=Object(r.N)(Object(r.pb)(e,i,p),this.elementShape)}return o}));const i=[];for(let e=0;e<t.length;e++)i[e]=e;this.writeMany(i,o)}}class X{constructor(t,e,a,n=-1){this.tensors=t,this.elementShape=e,this.elementDtype=a,null!=t&&t.forEach((t=>{if(a!==t.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${t.dtype}`);Q(e,t.shape,"TensorList shape mismatch: "),Object(r.H)(t)})),this.idTensor=Object(r.G)(0),this.maxNumElements=n,Object(r.H)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new X([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.id)||e.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,a=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);return Q(t,this.elementShape,"TensorList shape mismatch: "),Object(r.M)((()=>{const e=this.tensors.map((e=>Object(r.N)(e,t)));return Object(r.J)(e,0)}))}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const a=this.tensors.pop();return Q(a.shape,t,"TensorList shape mismatch: "),Object(r.N)(a,t)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Q(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Object(r.H)(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);return Q(this.tensors[t].shape,e,"TensorList shape mismatch: "),this.tensors[t]}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Q(this.elementShape,e.shape,"TensorList shape mismatch: "),Object(r.H)(e),this.tensors[t]=e}gather(t,e,a){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);return Q(this.elementShape,a,"TensorList shape mismatch: "),0===(t=t.slice(0,this.size())).length?Object(r.I)([],[0].concat(this.elementShape)):Object(r.M)((()=>{const e=t.map((t=>Object(r.N)(this.tensors[t],a)));return Object(r.J)(e,0)}))}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);return Q(this.elementShape,e,"TensorList shape mismatch: "),0===this.size()?Object(r.I)([],[0].concat(this.elementShape)):Object(r.M)((()=>{const t=this.tensors.map((t=>Object(r.N)(t,e)));return Object(r.K)(t,0)}))}}const Z=async(t,e,a)=>{switch(t.op){case"If":case"StatelessIf":{const n=m("thenBranch",t,e,a),s=m("elseBranch",t,e,a),r=m("cond",t,e,a),o=m("args",t,e,a);return(await r.data())[0]?a.functionMap[n].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap):a.functionMap[s].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{const n=m("body",t,e,a),s=m("cond",t,e,a),r=m("args",t,e,a),o=await a.functionMap[s].executeFunctionAsync(r,a.tensorArrayMap,a.tensorListMap),i=r.map((t=>t.id));let p=await o[0].data();o.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||t.dispose()}));let u=r;for(;p[0];){const t=u;u=await a.functionMap[n].executeFunctionAsync(u,a.tensorArrayMap,a.tensorListMap);const e=u.map((t=>t.id));t.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}));const r=await a.functionMap[s].executeFunctionAsync(u,a.tensorArrayMap,a.tensorListMap);p=await r[0].data(),r.forEach((t=>{t.kept||-1!==i.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}))}return u}case"LoopCond":return[h(m("pred",t,e,a))];case"Switch":{const n=m("pred",t,e,a);let s=m("data",t,e,a);return s.kept||(s=h(s)),(await n.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const n=t.inputNames.find((t=>void 0!==u(t,e,a)));if(n){return[h(u(n,e,a))]}return}case"Enter":{const n=m("frameName",t,e,a),s=m("tensor",t,e,a);return a.enterFrame(n),[h(s)]}case"Exit":{const n=m("tensor",t,e,a);return a.exitFrame(),[h(n)]}case"NextIteration":{const n=m("tensor",t,e,a);return a.nextIteration(),[h(n)]}case"TensorArrayV3":{const n=m("size",t,e,a),s=m("dtype",t,e,a),o=m("elementShape",t,e,a),i=m("dynamicSize",t,e,a),p=m("clearAfterRead",t,e,a),u=m("identicalElementShapes",t,e,a),c=m("name",t,e,a),d=new J(c,s,n,o,u,i,p);return a.addTensorArray(d),[d.idTensor,Object(r.G)(1)]}case"TensorArrayWriteV3":{const n=m("tensorArrayId",t,e,a),s=m("index",t,e,a),r=m("tensor",t,e,a),o=a.getTensorArray(n.id);return o.write(s,r),[o.idTensor]}case"TensorArrayReadV3":{const n=m("tensorArrayId",t,e,a),s=m("index",t,e,a);return[a.getTensorArray(n.id).read(s)]}case"TensorArrayGatherV3":{const n=m("tensorArrayId",t,e,a),s=m("indices",t,e,a),r=m("dtype",t,e,a);return[a.getTensorArray(n.id).gather(s,r)]}case"TensorArrayScatterV3":{const n=m("tensorArrayId",t,e,a),s=m("indices",t,e,a),r=m("tensor",t,e,a),o=a.getTensorArray(n.id);return o.scatter(s,r),[o.idTensor]}case"TensorArrayConcatV3":{const n=m("tensorArrayId",t,e,a),s=a.getTensorArray(n.id),r=m("dtype",t,e,a);return[s.concat(r)]}case"TensorArraySplitV3":{const n=m("tensorArrayId",t,e,a),s=m("tensor",t,e,a),r=m("lengths",t,e,a),o=a.getTensorArray(n.id);return o.split(r,s),[o.idTensor]}case"TensorArraySizeV3":{const n=m("tensorArrayId",t,e,a),s=a.getTensorArray(n.id);return[Object(r.G)(s.size(),"int32")]}case"TensorArrayCloseV3":{const n=m("tensorArrayId",t,e,a),s=a.getTensorArray(n.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const n=m("tensorListId",t,e,a),s=m("index",t,e,a),r=m("tensor",t,e,a),o=a.getTensorList(n.id);return o.setItem(s,r),[o.idTensor]}case"TensorListGetItem":{const n=m("tensorListId",t,e,a),s=m("index",t,e,a),r=m("elementShape",t,e,a),o=m("elementDType",t,e,a);return[a.getTensorList(n.id).getItem(s,r,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=m("indices",t,e,a),s=function(t,e,a,n){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(null!=n&&-1!==n&&s>=n)throw new Error(`Max index must be < array size (${s}  vs. ${n})`);const o=new X([],a,t.dtype,n),i=Object(r.L)(t,0);return e.forEach(((t,e)=>{o.setItem(t,i[e])})),o}(m("tensor",t,e,a),n,m("elementShape",t,e,a),m("numElements",t,e,a));return a.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=m("elementShape",t,e,a),s=m("elementDType",t,e,a);let r;r="TensorListReserve"===t.op?"numElements":"maxNumElements";const o=function(t,e,a){return new X([],t,e,a)}(n,s,m(r,t,e,a));return a.addTensorList(o),[o.idTensor]}case"TensorListGather":{const n=m("tensorListId",t,e,a),s=m("indices",t,e,a),r=m("elementShape",t,e,a),o=m("elementDType",t,e,a);return[a.getTensorList(n.id).gather(s,o,r)]}case"TensorListStack":{const n=m("tensorListId",t,e,a),s=m("elementShape",t,e,a),r=m("elementDType",t,e,a),o=m("numElements",t,e,a);return[a.getTensorList(n.id).stack(s,r,o)]}case"TensorListFromTensor":{const n=function(t,e,a){const n=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==a)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${a}`);Q(t.shape.slice(1),e,"TensorList shape mismatch: ");const s=Object(r.L)(t);return new X(s,e,n)}(m("tensor",t,e,a),m("elementShape",t,e,a),m("elementDType",t,e,a));return a.addTensorList(n),[n.idTensor]}case"TensorListConcat":{const n=m("tensorListId",t,e,a),s=a.getTensorList(n.id),r=m("dtype",t,e,a),o=m("elementShape",t,e,a);return[s.concat(r,o)]}case"TensorListPushBack":{const n=m("tensorListId",t,e,a),s=m("tensor",t,e,a),r=a.getTensorList(n.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const n=m("tensorListId",t,e,a),s=m("elementShape",t,e,a),r=m("elementDType",t,e,a);return[a.getTensorList(n.id).popBack(s,r)]}case"TensorListSplit":{const n=m("tensor",t,e,a),s=m("elementShape",t,e,a),o=function(t,e,a){let n=0;const s=e.map((t=>(n+=t,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);const o=0===n?0:t.size/n,i=Object(r.M)((()=>{const i=[];t=Object(r.N)(t,[1,n,o]);for(let n=0;n<e.length;++n){const p=[0,0===n?0:s[n-1],0],m=[1,e[n],o];i[n]=Object(r.N)(Object(r.pb)(t,p,m),a)}return t.dispose(),i})),p=new X([],a,t.dtype,e.length);for(let t=0;t<i.length;t++)p.setItem(t,i[t]);return p}(n,m("lengths",t,e,a),s);return a.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};function Y(t,e,a){const[n,s]=m("fusedOps",t,e,a),r="biasadd"===n,o="prelu"===s,i="fusedbatchnorm"===n,p=m("numArgs",t,e,a);if(r){if(o&&2!==p)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==p)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const u=m("strides",t,e,a),c=y(t,e,a),d=m("dataFormat",t,e,a).toUpperCase(),l=m("dilations",t,e,a),[h,f]=m("args",t,e,a);return{stride:u,pad:c,dataFormat:d,dilations:l,biasArg:h,preluArg:f,activationFunc:s,leakyreluAlpha:m("leakyreluAlpha",t,e,a)}}function tt(t,e,a){return{boxes:m("boxes",t,e,a),scores:m("scores",t,e,a),maxOutputSize:m("maxOutputSize",t,e,a),iouThreshold:m("iouThreshold",t,e,a),scoreThreshold:m("scoreThreshold",t,e,a),softNmsSigma:m("softNmsSigma",t,e,a)}}class et{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Object(r.G)(0),this.tensorMap=new Map,Object(r.H)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}async import(t,e){this.checkKeyAndValueTensor(t,e);const a=await t.data();return this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),Object(r.M)((()=>{const t=Object(r.L)(e),n=a.length,s=t.length;Object(r.F)(n===s,(()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${s} elements.`));for(let e=0;e<n;e++){const n=a[e],s=t[e];Object(r.H)(s),this.tensorMap.set(n,s)}return this.handle}))}async find(t,e){this.checkKeyAndValueTensor(t,e);const a=await t.data();return Object(r.M)((()=>{const t=[];for(let n=0;n<a.length;n++){const s=a[n],r=this.findWithDefault(s,e);t.push(r)}return Object(r.J)(t)}))}findWithDefault(t,e){const a=this.tensorMap.get(t);return null!=a?a:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}function at(t,e,a,n){const s=((t,e,a)=>{switch(t.category){case"arithmetic":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[Object(r.oh)(m("a",t,e,a),m("b",t,e,a))];case"AddN":return[Object(o.h)(m("tensors",t,e,a))];case"FloorMod":case"Mod":return[Object(r.nh)(m("a",t,e,a),m("b",t,e,a))];case"Mul":return[Object(r.mh)(m("a",t,e,a),m("b",t,e,a))];case"RealDiv":case"Div":return[Object(r.kh)(m("a",t,e,a),m("b",t,e,a))];case"DivNoNan":return[Object(r.pe)(m("a",t,e,a),m("b",t,e,a))];case"FloorDiv":return[Object(r.Og)(m("a",t,e,a),m("b",t,e,a))];case"Sub":return[Object(r.Pb)(m("a",t,e,a),m("b",t,e,a))];case"Minimum":return[Object(r.C)(m("a",t,e,a),m("b",t,e,a))];case"Maximum":return[Object(r.rh)(m("a",t,e,a),m("b",t,e,a))];case"Pow":return[Object(r.uh)(m("a",t,e,a),m("b",t,e,a))];case"SquaredDifference":return[Object(r.xh)(m("a",t,e,a),m("b",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"basic_math":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"Abs":case"ComplexAbs":return[Object(r.E)(m("x",t,e,a))];case"Acos":return[Object(r.a)(m("x",t,e,a))];case"Acosh":return[Object(r.B)(m("x",t,e,a))];case"Asin":return[Object(r.A)(m("x",t,e,a))];case"Asinh":return[Object(r.z)(m("x",t,e,a))];case"Atan":return[Object(r.y)(m("x",t,e,a))];case"Atan2":return[Object(r.x)(m("x",t,e,a),m("y",t,e,a))];case"Atanh":return[Object(r.w)(m("x",t,e,a))];case"Ceil":return[Object(r.v)(m("x",t,e,a))];case"Complex":return[Object(r.u)(m("real",t,e,a),m("imag",t,e,a))];case"Cos":return[Object(r.t)(m("x",t,e,a))];case"Cosh":return[Object(r.s)(m("x",t,e,a))];case"Elu":return[Object(r.r)(m("x",t,e,a))];case"Erf":return[Object(r.q)(m("x",t,e,a))];case"Exp":return[Object(r.p)(m("x",t,e,a))];case"Expm1":return[Object(r.o)(m("x",t,e,a))];case"Floor":return[Object(r.n)(m("x",t,e,a))];case"Log":return[Object(r.m)(m("x",t,e,a))];case"Log1p":return[Object(r.l)(m("x",t,e,a))];case"Imag":return[Object(r.k)(m("x",t,e,a))];case"Neg":return[Object(r.j)(m("x",t,e,a))];case"Reciprocal":return[Object(r.i)(m("x",t,e,a))];case"Real":return[Object(r.h)(m("x",t,e,a))];case"Relu":return[Object(r.g)(m("x",t,e,a))];case"Round":return[Object(r.f)(m("x",t,e,a))];case"Selu":return[Object(r.e)(m("x",t,e,a))];case"Sigmoid":return[Object(r.d)(m("x",t,e,a))];case"Sin":return[Object(r.c)(m("x",t,e,a))];case"Sign":return[Object(r.b)(m("x",t,e,a))];case"Sinh":return[Object(r.Eh)(m("x",t,e,a))];case"Softplus":return[Object(r.Dh)(m("x",t,e,a))];case"Sqrt":return[Object(r.Ch)(m("x",t,e,a))];case"Square":return[Object(r.Bh)(m("x",t,e,a))];case"Tanh":return[Object(r.Ah)(m("x",t,e,a))];case"Tan":return[Object(r.zh)(m("x",t,e,a))];case"ClipByValue":return[Object(r.vh)(m("x",t,e,a),m("clipValueMin",t,e,a),m("clipValueMax",t,e,a))];case"Relu6":return[Object(r.th)(m("x",t,e,a))];case"Rsqrt":return[Object(r.wh)(u(t.inputNames[0],e,a))];case"Prod":return[Object(r.sh)(m("x",t,e,a),m("axes",t,e,a))];case"LeakyRelu":return[Object(r.qh)(m("x",t,e,a),m("alpha",t,e,a))];case"Prelu":return[Object(r.ph)(m("x",t,e,a),m("alpha",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"control":return Z(t,e,a);case"convolution":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"Conv1D":{const n=m("stride",t,e,a),s=m("pad",t,e,a),o=m("dataFormat",t,e,a).toUpperCase(),i=m("dilation",t,e,a);return[Object(r.wb)(m("x",t,e,a),m("filter",t,e,a),n,s,o,i)]}case"Conv2D":{const n=m("strides",t,e,a),s=y(t,e,a),o=m("dataFormat",t,e,a).toUpperCase(),i=m("dilations",t,e,a);return[Object(r.vb)(m("x",t,e,a),m("filter",t,e,a),[n[1],n[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:n,pad:s,dataFormat:r,dilations:i,biasArg:p,preluArg:u,activationFunc:c,leakyreluAlpha:d}=Y(t,e,a);return[Object(o.m)({x:m("x",t,e,a),filter:m("filter",t,e,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[i[1],i[2]],bias:p,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:s,dataFormat:r,dilations:i,biasArg:p,preluArg:u,activationFunc:c,leakyreluAlpha:d}=Y(t,e,a);return[Object(o.l)({x:m("x",t,e,a),filter:m("filter",t,e,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[i[1],i[2]],bias:p,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=m("outputShape",t,e,a),s=m("strides",t,e,a),o=y(t,e,a);return[Object(r.ub)(m("x",t,e,a),m("filter",t,e,a),n,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=m("strides",t,e,a),s=y(t,e,a),o=m("dilations",t,e,a),i=m("dataFormat",t,e,a).toUpperCase();return[Object(r.tb)(m("input",t,e,a),m("filter",t,e,a),[n[1],n[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const n=m("strides",t,e,a),s=m("pad",t,e,a),r=m("dataFormat",t,e,a).toUpperCase(),i=m("dilations",t,e,a);return[Object(o.k)(m("x",t,e,a),m("filter",t,e,a),[n[1],n[2],n[3]],s,r,[i[1],i[2],i[3]])]}case"AvgPool":{const n=m("strides",t,e,a),s=m("pad",t,e,a),o=m("kernelSize",t,e,a);return[Object(r.sb)(m("x",t,e,a),[o[1],o[2]],[n[1],n[2]],s)]}case"MaxPool":{const n=m("strides",t,e,a),s=m("pad",t,e,a),o=m("kernelSize",t,e,a);return[Object(r.rb)(m("x",t,e,a),[o[1],o[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{const n=m("strides",t,e,a),s=m("pad",t,e,a),r=m("kernelSize",t,e,a),i=m("includeBatchInIndex",t,e,a),{result:p,indexes:u}=Object(o.j)(m("x",t,e,a),[r[1],r[2]],[n[1],n[2]],s,i);return[p,u]}case"AvgPool3D":{const n=m("strides",t,e,a),s=m("pad",t,e,a),r=m("kernelSize",t,e,a);return[Object(o.i)(m("x",t,e,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{const n=m("strides",t,e,a),s=m("pad",t,e,a),r=m("kernelSize",t,e,a);return[Object(o.t)(m("x",t,e,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{const n=m("strides",t,e,a),s=m("pad",t,e,a),o=m("dilations",t,e,a),i=n[1],p=n[2],u=o[1],c=o[2];return[Object(r.qb)(m("x",t,e,a),m("filter",t,e,a),[i,p],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"creation":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"Fill":{const n=m("shape",t,e,a),s=m("dtype",t,e,a),r=m("value",t,e,a);return[Object(o.p)(n,r,s)]}case"LinSpace":{const n=m("start",t,e,a),s=m("stop",t,e,a),r=m("num",t,e,a);return[Object(o.s)(n,s,r)]}case"Multinomial":{const n=m("logits",t,e,a),s=m("numSamples",t,e,a),r=m("seed",t,e,a);return[Object(o.o)(n,s,r)]}case"OneHot":{const n=m("indices",t,e,a),s=m("depth",t,e,a),o=m("onValue",t,e,a),i=m("offValue",t,e,a);return[Object(r.Bb)(n,s,o,i)]}case"Ones":return[Object(r.Ab)(m("shape",t,e,a),m("dtype",t,e,a))];case"OnesLike":return[Object(r.zb)(m("x",t,e,a))];case"RandomUniform":return[Object(o.n)(m("shape",t,e,a),m("minval",t,e,a),m("maxval",t,e,a),m("dtype",t,e,a))];case"Range":{const n=m("start",t,e,a),s=m("stop",t,e,a),r=m("step",t,e,a);return[Object(o.y)(n,s,r,m("dtype",t,e,a))]}case"TruncatedNormal":{const n=m("shape",t,e,a),s=m("mean",t,e,a),r=m("stdDev",t,e,a),i=m("seed",t,e,a);return[Object(o.A)(n,s,r,m("dtype",t,e,a),i)]}case"Zeros":return[Object(r.yb)(m("shape",t,e,a),m("dtype",t,e,a))];case"ZerosLike":return[Object(r.xb)(m("x",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"dynamic":return(async(t,e,a)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:i,scoreThreshold:p,softNmsSigma:m}=tt(t,e,a),u=await o.q.nonMaxSuppressionWithScoreAsync(n,s,r,i,p,m);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:i,scoreThreshold:p}=tt(t,e,a),u=m("padToMaxOutputSize",t,e,a),c=await o.q.nonMaxSuppressionPaddedAsync(n,s,r,i,p,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:i,scoreThreshold:p}=tt(t,e,a);return[await o.q.nonMaxSuppressionAsync(n,s,r,i,p)]}case"Where":{const n=Object(r.Cb)(m("condition",t,e,a),"bool"),s=[await Object(o.D)(n)];return n.dispose(),s}case"ListDiff":return Object(o.z)(m("x",t,e,a),m("y",t,e,a));default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a);case"evaluation":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"TopKV2":{const n=m("x",t,e,a),s=m("k",t,e,a),o=m("sorted",t,e,a),i=Object(r.Eb)(n,s,o);return[i.values,i.indices]}case"Unique":{const n=m("x",t,e,a),s=Object(r.Db)(n);return[s.values,s.indices]}case"UniqueV2":{const n=m("x",t,e,a),s=m("axis",t,e,a),o=Object(r.Db)(n,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"image":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"ResizeBilinear":{const n=m("images",t,e,a),s=m("size",t,e,a),r=m("alignCorners",t,e,a),i=m("halfPixelCenters",t,e,a);return[o.q.resizeBilinear(n,[s[0],s[1]],r,i)]}case"ResizeNearestNeighbor":{const n=m("images",t,e,a),s=m("size",t,e,a),r=m("alignCorners",t,e,a),i=m("halfPixelCenters",t,e,a);return[o.q.resizeNearestNeighbor(n,[s[0],s[1]],r,i)]}case"CropAndResize":{const n=m("image",t,e,a),s=m("boxes",t,e,a),r=m("boxInd",t,e,a),i=m("cropSize",t,e,a),p=m("method",t,e,a),u=m("extrapolationValue",t,e,a);return[o.q.cropAndResize(n,s,r,i,p,u)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"graph":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const n=m("default",t,e,a);return[u(t.name,e,a)||n];case"Placeholder":return[u(t.name,e,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[h(m("x",t,e,a))];case"IdentityN":return m("x",t,e,a).map((t=>h(t)));case"Snapshot":return[h(m("x",t,e,a))];case"Shape":return[Object(o.r)(m("x",t,e,a).shape,"int32")];case"ShapeN":return m("x",t,e,a).map((t=>Object(o.r)(t.shape)));case"Size":return[Object(r.G)(m("x",t,e,a).size,"int32")];case"Rank":return[Object(r.G)(m("x",t,e,a).rank,"int32")];case"NoOp":return[Object(r.G)(1)];case"Print":const s=m("x",t,e,a),i=m("data",t,e,a),p=m("message",t,e,a),c=m("summarize",t,e,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(p);for(let t=0;t<i.length;t++)console.log(Array.prototype.slice.call(i[t].dataSync()).slice(0,c));return[s];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"logical":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"Equal":return[Object(r.Ob)(m("a",t,e,a),m("b",t,e,a))];case"NotEqual":return[Object(r.Nb)(m("a",t,e,a),m("b",t,e,a))];case"Greater":return[Object(r.Mb)(m("a",t,e,a),m("b",t,e,a))];case"GreaterEqual":return[Object(r.Lb)(m("a",t,e,a),m("b",t,e,a))];case"Less":return[Object(r.Kb)(m("a",t,e,a),m("b",t,e,a))];case"LessEqual":return[Object(r.Jb)(m("a",t,e,a),m("b",t,e,a))];case"LogicalAnd":return[Object(r.Ib)(m("a",t,e,a),m("b",t,e,a))];case"LogicalNot":return[Object(r.Hb)(m("a",t,e,a))];case"LogicalOr":return[Object(r.Gb)(m("a",t,e,a),m("b",t,e,a))];case"Select":case"SelectV2":return[Object(r.Fb)(m("condition",t,e,a),m("a",t,e,a),m("b",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"matrices":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Object(r.P)(m("a",t,e,a),m("b",t,e,a),m("transposeA",t,e,a),m("transposeB",t,e,a))];case"Transpose":return[Object(r.O)(m("x",t,e,a),m("perm",t,e,a))];case"_FusedMatMul":const[n,s]=m("fusedOps",t,e,a),i="biasadd"===n,p="prelu"===s,u=m("numArgs",t,e,a),c=m("leakyreluAlpha",t,e,a);if(i){if(p&&2!==u)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!p&&1!==u)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,l]=m("args",t,e,a);return[Object(o.u)({a:m("a",t,e,a),b:m("b",t,e,a),transposeA:m("transposeA",t,e,a),transposeB:m("transposeB",t,e,a),bias:d,activation:s,preluActivationWeights:l,leakyreluAlpha:c})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"normalization":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Object(r.T)(m("x",t,e,a),m("mean",t,e,a),m("variance",t,e,a),m("offset",t,e,a),m("scale",t,e,a),m("epsilon",t,e,a))];case"LRN":return[Object(r.S)(m("x",t,e,a),m("radius",t,e,a),m("bias",t,e,a),m("alpha",t,e,a),m("beta",t,e,a))];case"Softmax":return[Object(r.R)(m("x",t,e,a))];case"LogSoftmax":return[Object(r.Q)(m("x",t,e,a))];case"SparseToDense":return[Object(o.v)(m("sparseIndices",t,e,a),m("outputShape",t,e,a),m("sparseValues",t,e,a),m("defaultValue",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"reduction":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"Max":{const n=m("axis",t,e,a),s=m("keepDims",t,e,a);return[Object(r.cb)(m("x",t,e,a),n,s)]}case"Mean":{const n=m("axis",t,e,a),s=m("keepDims",t,e,a);return[Object(r.bb)(m("x",t,e,a),n,s)]}case"Min":{const n=m("axis",t,e,a),s=m("keepDims",t,e,a);return[Object(r.ab)(m("x",t,e,a),n,s)]}case"Sum":{const n=m("axis",t,e,a),s=m("keepDims",t,e,a);return[Object(r.Z)(m("x",t,e,a),n,s)]}case"All":{const n=m("axis",t,e,a),s=m("keepDims",t,e,a);return[Object(r.Y)(m("x",t,e,a),n,s)]}case"Any":{const n=m("axis",t,e,a),s=m("keepDims",t,e,a);return[Object(r.X)(m("x",t,e,a),n,s)]}case"ArgMax":{const n=m("axis",t,e,a);return[Object(r.W)(m("x",t,e,a),n)]}case"ArgMin":{const n=m("axis",t,e,a);return[Object(r.V)(m("x",t,e,a),n)]}case"Prod":{const n=m("axis",t,e,a),s=m("keepDims",t,e,a);return[Object(r.sh)(m("x",t,e,a),n,s)]}case"Cumsum":{const n=m("axis",t,e,a),s=m("exclusive",t,e,a),o=m("reverse",t,e,a);return[Object(r.U)(m("x",t,e,a),n,s,o)]}case"Bincount":const n=m("x",t,e,a),s=m("weights",t,e,a),i=m("size",t,e,a);return[Object(o.x)(n,s,i)];case"DenseBincount":{const n=m("x",t,e,a),s=m("weights",t,e,a),r=m("size",t,e,a),i=m("binaryOutput",t,e,a);return[Object(o.w)(n,s,r,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"slice_join":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"ConcatV2":case"Concat":{const n=m("n",t,e,a),s=m("axis",t,e,a);let o=m("tensors",t,e,a);return o=o.slice(0,n),[Object(r.K)(o,s)]}case"Gather":{const n=m("x",t,e,a),s=m("indices",t,e,a);return[Object(r.jb)(n,Object(r.Cb)(s,"int32"),0)]}case"GatherV2":{const n=m("axis",t,e,a),s=m("batchDims",t,e,a),o=m("x",t,e,a),i=m("indices",t,e,a);return[Object(r.jb)(o,Object(r.Cb)(i,"int32"),n,s)]}case"Reverse":{const n=m("dims",t,e,a),s=[];for(let t=0;t<n.length;t++)n[t]&&s.push(t);const o=m("x",t,e,a);return[Object(r.ib)(o,s)]}case"ReverseV2":{const n=m("axis",t,e,a),s=m("x",t,e,a);return[Object(r.ib)(s,n)]}case"Slice":{const n=m("begin",t,e,a),s=m("size",t,e,a);return[Object(r.pb)(m("x",t,e,a),n,s)]}case"StridedSlice":{const n=m("begin",t,e,a),s=m("end",t,e,a),o=m("strides",t,e,a),i=m("beginMask",t,e,a),p=m("endMask",t,e,a),u=m("ellipsisMask",t,e,a),c=m("newAxisMask",t,e,a),d=m("shrinkAxisMask",t,e,a),l=m("x",t,e,a);return[Object(r.hb)(l,n,s,o,i,p,u,c,d)]}case"Pack":return Object(r.M)((()=>{const n=m("axis",t,e,a),s=m("tensors",t,e,a),o=s[0].shape,i=Object(r.fb)(s[0]).shape,p=s.map((t=>{const e=Object(r.gb)(t.shape,o);if(!e&&!Object(r.gb)(Object(r.fb)(t).shape,i))throw new Error("the input tensors shape does not match");return e?t:Object(r.N)(t,o)}));return[Object(r.J)(p,n)]}));case"Unpack":{const n=m("axis",t,e,a),s=m("tensor",t,e,a);return Object(r.L)(s,n)}case"Tile":{const n=m("reps",t,e,a);return[Object(r.eb)(m("x",t,e,a),n)]}case"Split":case"SplitV":{const n=m("axis",t,e,a),s=m("numOrSizeSplits",t,e,a),o=m("x",t,e,a);return Object(r.db)(o,s,n)}case"ScatterNd":{const n=m("indices",t,e,a),s=m("values",t,e,a),r=m("shape",t,e,a);return[Object(o.C)(n,s,r)]}case"GatherNd":{const n=m("x",t,e,a),s=m("indices",t,e,a);return[Object(o.B)(n,s)]}case"SparseToDense":{const n=m("sparseIndices",t,e,a),s=m("outputShape",t,e,a),i=m("sparseValues",t,e,a),p=m("defaultValue",t,e,a);return[Object(o.v)(n,i,s,i.dtype===p.dtype?p:Object(r.Cb)(p,i.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"spectral":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"FFT":return[Object(r.nb)(m("x",t,e,a))];case"IFFT":return[Object(r.mb)(m("x",t,e,a))];case"RFFT":return[Object(r.lb)(m("x",t,e,a))];case"IRFFT":return[Object(r.kb)(m("x",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"transformation":return Object(r.M)((()=>((t,e,a)=>{switch(t.op){case"Cast":return[Object(r.Cb)(m("x",t,e,a),m("dtype",t,e,a))];case"ExpandDims":{const n=m("axis",t,e,a);return[Object(r.Vb)(m("x",t,e,a),n)]}case"Squeeze":{const n=m("axis",t,e,a);return[Object(r.fb)(m("x",t,e,a),n)]}case"Reshape":return[Object(r.N)(m("x",t,e,a),m("shape",t,e,a))];case"MirrorPad":return[Object(r.Ub)(m("x",t,e,a),m("padding",t,e,a),m("mode",t,e,a))];case"PadV2":case"Pad":return[Object(r.Tb)(m("x",t,e,a),m("padding",t,e,a),m("constantValue",t,e,a))];case"SpaceToBatchND":{const n=m("blockShape",t,e,a),s=m("paddings",t,e,a);return[Object(r.Sb)(m("x",t,e,a),n,s)]}case"BatchToSpaceND":{const n=m("blockShape",t,e,a),s=m("crops",t,e,a);return[Object(r.Rb)(m("x",t,e,a),n,s)]}case"DepthToSpace":{const n=m("blockSize",t,e,a),s=m("dataFormat",t,e,a).toUpperCase();return[Object(r.D)(m("x",t,e,a),n,s)]}case"BroadcastTo":return[Object(r.ob)(m("x",t,e,a),m("shape",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"hash_table":return(async(t,e,a,n)=>{switch(t.op){case"HashTable":case"HashTableV2":{const s=m("keyDType",t,e,a),r=m("valueDType",t,e,a),o=new et(s,r);return n.addHashTable(t.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=m("tableHandle",t,e,a,n),r=m("keys",t,e,a),o=m("values",t,e,a),i=n.getHashTableById(s.id);return[await i.import(r,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=m("tableHandle",t,e,a,n),r=m("keys",t,e,a),o=m("defaultValue",t,e,a),i=n.getHashTableById(s.id);return[await i.find(r,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a,n);case"custom":const s=p(t.op);if(s&&s.customExecutor)return s.customExecutor(new K(t,e,a));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,a);return Object(r.Wb)(s)?s.then((t=>[].concat(t))):[].concat(s)}class nt{constructor(t={},e={},a={},n={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=a,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const a=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(a))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map((t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`)).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function st(t,e,a,n){const s=new Set,r=[];let o=null,i=null;const p=new Set,m=Object.keys(t).map((t=>l(t)[0]));let u=[];null!=n&&(u=n.map((t=>l(t.name)[0])));const c=[...e];for(;c.length>0;){const t=c.pop();(pt(t)||mt(t)||ut(t))&&null==o&&(o=t,i=o.children.map((t=>t.name)).filter((t=>s.has(t)))),s.add(t.name),null==a[t.name]&&(-1===m.indexOf(t.name)&&-1===u.indexOf(t.name)&&(0!==t.inputs.length?t.inputs.forEach((t=>{p.has(t.name)||(p.add(t.name),c.push(t))})):r.push(t.name)))}return{inputs:t,outputs:e,usedNodes:s,missingInputs:r,dynamicNode:o,syncInputs:i}}const rt=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],ot=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],it=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2"];function pt(t){return rt.indexOf(t.op)>=0}function mt(t){return ot.indexOf(t.op)>=0}function ut(t){return it.indexOf(t.op)>=0}class ct{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((e=>{this._functionExecutorMap[e]=new ct(t.functions[e],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map((e=>t[e].map((t=>t.id))));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((t=>t.signatureKey||t.name))}get outputNodes(){return this._outputs.map((t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e}))}get functions(){return Object.keys(this._functions).reduce(((t,e)=>(t[e]=this._functions[e].signature,t)),{})}getCompilationKey(t,e){const a=t.map((t=>t.name)).sort(),n=e.map((t=>t.name)).sort();return a.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(t,e){const a=st(t,e,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:s,syncInputs:r}=a;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(n.length>0){const a=e.map((t=>t.name)),s=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${s}]. Missing the following inputs: [${n}]`)}return function(t,e,a){const{usedNodes:n,inputs:s}=a,r=[],o=Object.keys(s).map((t=>l(t)[0])).map((e=>t.nodes[e])),i=t.initNodes;o.forEach((t=>{n.has(t.name)&&r.push(t)})),t.weights.forEach((t=>{n.has(t.name)&&r.push(t)})),null!=i&&i.forEach((t=>{n.has(t.name)&&r.push(t)}));const p=new Set,m=[];for(;r.length>0;){const t=r.pop();p.add(t.name),e[t.name]||m.push(t),t.children.forEach((t=>{!p.has(t.name)&&n.has(t.name)&&t.inputs.every((t=>p.has(t.name)))&&r.push(t)}))}return m}(this.graph,this.weightMap,a)}execute(t,e){t=this.mapInputs(t);const a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const n=a.map((t=>this.graph.nodes[l(t)[0]])),s=e.map((t=>l(t)[0]));let o=s.map((t=>this.graph.nodes[t]));0===o.length&&(o=this._outputs);const i=this.getCompilationKey(n,o);let p=this.compiledMap.get(i);null==p&&(p=this.compile(t,o),this.compiledMap.set(i,p));const m={},c={};return Object(r.M)((()=>{const a=new nt(this.weightMap,m,c,this.functionExecutorMap),n=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[a,s]=l(e),r=[];r[s]=t[e],n[a]=r}));const o=this.getFrozenTensorIds(n),i={};for(let t=0;t<p.length;t++){const e=p[t];if(!n[e.name]){const t=at(e,n,a,this._resourceManager);if(Object(r.Wb)(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);n[e.name]=t,this.checkTensorForDisposal(e.name,e,n,a,o,s,i)}}return null==this.parent&&a.dispose(o),e.map((t=>u(t,n,a)))}))}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map((e=>t[e])).map((t=>t.map((t=>t.id)))));return new Set(e)}checkTensorForDisposal(t,e,a,n,s,r,o){"control"!==e.category&&-1===r.indexOf(t)&&(a[t].forEach((t=>{null!=t&&(o[t.id]=(o[t.id]||0)+e.children.length)})),e.inputs.forEach((t=>{if("control"!==t.category){const e=function(t,e,a){return e[d(t,a.currentContextId)]}(t.name,a,n);null!=e&&e.forEach((t=>{if(t&&!s.has(t.id)){const e=o[t.id];1===e?(t.dispose(),delete o[t.id]):null!=e&&o[t.id]--}}))}})))}async executeAsync(t,e){return this._executeAsync(t,e)}async _executeAsync(t,e,a=!1,n={},s={}){a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));const r=new nt(this.weightMap,n,s,this.functionExecutorMap),o=await this.executeWithControlFlow(t,r,e,a),i=e.map((t=>u(t,o,r))),p=i.map((t=>t.id)),m=Object.keys(t).map((e=>t[e].id)),c=new Set([...p,...m,...this.weightIds]);return Object.keys(o).forEach((t=>{o[t].forEach((t=>{!t||t.isDisposed||c.has(t.id)||t.dispose()}))})),null==this.parent&&r.dispose(c),i}async executeFunctionAsync(t,e,a){const n=t.reduce(((t,e,a)=>(t[this.inputs[a].name]=e,t)),{});return this._executeAsync(n,this.outputNodes,!0,e,a)}async executeWithControlFlow(t,e,a,n){const s=Object.keys(t),r=s.map((t=>this.graph.nodes[l(t)[0]])),o=a.map((t=>l(t)[0]));let i=o.map((t=>this.graph.nodes[t]));0===i.length&&(i=this._outputs);const{usedNodes:p,missingInputs:m,dynamicNode:c,syncInputs:d}=st(t,i,this.weightMap,this._initNodes),y=[...r,...this.graph.weights,...this._initNodes||[]].map((t=>({node:t,contexts:e.currentContext}))),h=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[a,n]=l(e),s=[];s[n]=t[e],h[a]=s}));const f={},b=this.getFrozenTensorIds(h),g={};for(;y.length>0;){const t=this.processStack(r,y,e,h,g,b,o,f,p);await Promise.all(t)}null!=c||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=i.filter((t=>!pt(t)&&!u(t.name,h,e))).map((t=>t.name));if(N.length>0){let t="";throw null!=c&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${s}]. Consider providing the following inputs: [${m}]. ${t}`)}return h}processStack(t,e,a,n,s,o,i,p,u){const d=[];for(;e.length>0;){const t=e.pop();a.currentContext=t.contexts;let l="";if("Enter"===t.node.op&&m("isConstant",t.node,n,a)&&([l]=c(t.node.name,a)),null==n[t.node.name]){const m=at(t.node,n,a,this._resourceManager);l||([l]=c(t.node.name,a));const y=a.currentContext;Object(r.Wb)(m)?d.push(m.then((r=>(n[l]=r,a.currentContext=y,this.checkTensorForDisposal(l,t.node,n,a,o,i,p),this.processChildNodes(t.node,e,a,n,s,u),r)))):(n[l]=m,this.checkTensorForDisposal(l,t.node,n,a,o,i,p),this.processChildNodes(t.node,e,a,n,s,u))}else this.processChildNodes(t.node,e,a,n,s,u)}return d}processChildNodes(t,e,a,n,s,r){t.children.forEach((t=>{const[o]=c(t.name,a);!s[o]&&r.has(t.name)&&("Merge"===t.op?t.inputNames.some((t=>!!u(t,n,a)))&&(s[o]=!0,e.push({contexts:a.currentContext,node:t})):t.inputNames.every((t=>!!u(t,n,a)))&&(s[o]=!0,e.push({contexts:a.currentContext,node:t})))}))}dispose(){Object.keys(this.weightMap).forEach((t=>this.weightMap[t].forEach((t=>t.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((e=>{const a=t[e],[n]=l(e),s=this.graph.nodes[n];if(s.attrParams.shape&&s.attrParams.shape.value){const t=s.attrParams.shape.value,e=t.length===a.shape.length&&a.shape.every(((e,a)=>-1===t[a]||t[a]===e));Object(r.F)(e,(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${t}], but was [${a.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&Object(r.F)(a.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`))}))}mapInputs(t){const e={};for(const a in t)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]){e[this._signature.inputs[a].name]=t[a]}else e[a]=t[a];return e}checkInputs(t){const e=Object.keys(t).filter((t=>{const[e]=l(t);return null==this.graph.nodes[e]}));if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map((t=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[t]){return this._signature.outputs[t].name}return t}),{})}checkOutputs(t){t.forEach((t=>{const[e]=l(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)}))}}class dt{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class lt{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={}),this.resourceManager=new dt}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=Object(o.E)(t,this.loadOptions);else{const e=Object(r.Xb)(t,this.loadOptions);if(0===e.length)e.push(Object(o.E)(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let a;a=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=a,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const n=Object(r.Yb)(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new ct(k.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const e=k.Instance.transformGraph(t.modelInitializer);this.initializer=new ct(e),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if("string"==typeof t){const e=Object(r.Zb)(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof r.ac||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce(((e,a,n)=>(e[a]=t[n],e)),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const a=this.executor.execute(t,e);return a.length>1?a:a[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const a=await this.executor.executeAsync(t,e);return a.length>1?a:a[0]}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce(((e,a)=>(e[a]=[t[a]],e)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function yt(t,e={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t=`${t}model.json?tfjs-format=file`);const a=new lt(t,e);return await a.load(),a}var ht=function(){return(ht=Object.assign||function(t){for(var e,a=1,n=arguments.length;a<n;a++)for(var s in e=arguments[a])Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s]);return t}).apply(this,arguments)};function ft(t,e,a,n){return new(a||(a=Promise))((function(s,r){function o(t){try{p(n.next(t))}catch(t){r(t)}}function i(t){try{p(n.throw(t))}catch(t){r(t)}}function p(t){var e;t.done?s(t.value):(e=t.value,e instanceof a?e:new a((function(t){t(e)}))).then(o,i)}p((n=n.apply(t,e||[])).next())}))}function bt(t,e){var a,n,s,r,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return r={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function i(r){return function(i){return function(r){if(a)throw new TypeError("Generator is already executing.");for(;o;)try{if(a=1,n&&(s=2&r[0]?n.return:r[0]?n.throw||((s=n.return)&&s.call(n),0):n.next)&&!(s=s.call(n,r[1])).done)return s;switch(n=0,s&&(r=[2&r[0],s.value]),r[0]){case 0:case 1:s=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,n=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((s=(s=o.trys).length>0&&s[s.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!s||r[1]>s[0]&&r[1]<s[3])){o.label=r[1];break}if(6===r[0]&&o.label<s[1]){o.label=s[1],s=r;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(r);break}s[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],n=0}finally{a=s=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,i])}}}const gt=t=>({startEndTensor:t,startPoint:Object(r.pb)(t,[0,0],[-1,2]),endPoint:Object(r.pb)(t,[0,2],[-1,2])}),Nt={strides:[8,16],anchors:[2,6]};function Ot(t,e){let a,n,s;if(t.topLeft instanceof r.ac&&t.bottomRight instanceof r.ac){const[i,p]=Object(r.M)((()=>[Object(r.K)([Object(r.Pb)(e-1,t.topLeft.slice(0,1)),t.topLeft.slice(1,1)]),Object(r.K)([Object(r.Pb)(e-1,t.bottomRight.slice(0,1)),t.bottomRight.slice(1,1)])]));a=i,n=p,null!=t.landmarks&&(s=Object(r.M)((()=>{const a=Object(r.Pb)(Object(o.r)([e-1,0]),t.landmarks),n=Object(o.r)([1,-1]);return Object(r.mh)(a,n)})))}else{const[r,o]=t.topLeft,[i,p]=t.bottomRight;a=[e-1-r,o],n=[e-1-i,p],null!=t.landmarks&&(s=t.landmarks.map((t=>[e-1-t[0],t[1]])))}const i={topLeft:a,bottomRight:n};return null!=s&&(i.landmarks=s),null!=t.probability&&(i.probability=t.probability instanceof r.ac?t.probability.clone():t.probability),i}function xt(t,e){return Object(r.M)((()=>{let a;return a=t.hasOwnProperty("box")?t.box:t,((t,e)=>{const a=Object(r.mh)(t.startPoint,e),n=Object(r.mh)(t.endPoint,e),s=Object(o.G)([a,n],1);return gt(s)})(a,e).startEndTensor.squeeze()}))}class Tt{constructor(t,e,a,n,s,r){this.blazeFaceModel=t,this.width=e,this.height=a,this.maxFaces=n,this.anchorsData=function(t,e,a){const n=[];for(let s=0;s<a.strides.length;s++){const r=a.strides[s],o=Math.floor((e+r-1)/r),i=Math.floor((t+r-1)/r),p=a.anchors[s];for(let t=0;t<o;t++){const e=r*(t+.5);for(let t=0;t<i;t++){const a=r*(t+.5);for(let t=0;t<p;t++)n.push([a,e])}}}return n}(e,a,Nt),this.anchors=Object(o.F)(this.anchorsData),this.inputSizeData=[e,a],this.inputSize=Object(o.r)([e,a]),this.iouThreshold=s,this.scoreThreshold=r}async getBoundingBoxes(t,e,a=!0){const[n,s,i]=Object(r.M)((()=>{const e=t.resizeBilinear([this.width,this.height]),a=Object(r.mh)(Object(r.Pb)(e.div(255),.5),2),n=this.blazeFaceModel.predict(a).squeeze(),s=function(t,e,a){const n=Object(r.pb)(t,[0,1],[-1,2]),s=Object(r.oh)(n,e),i=Object(r.pb)(t,[0,3],[-1,2]),p=Object(r.kh)(i,a),m=Object(r.kh)(s,a),u=Object(r.kh)(p,2),c=Object(r.Pb)(m,u),d=Object(r.oh)(m,u),l=Object(r.mh)(c,a),y=Object(r.mh)(d,a);return Object(o.G)([l,y],1)}(n,this.anchors,this.inputSize),i=Object(r.pb)(n,[0,0],[-1,1]);return[n,s,Object(r.d)(i).squeeze()]})),p=console.warn;console.warn=()=>{};const m=o.q.nonMaxSuppression(s,i,this.maxFaces,this.iouThreshold,this.scoreThreshold);console.warn=p;const u=await m.array();m.dispose();let c=u.map((t=>Object(r.pb)(s,[t,0],[1,-1])));e||(c=await Promise.all(c.map((async t=>{const e=await t.array();return t.dispose(),e}))));const d=t.shape[1],l=t.shape[2];let y;y=e?Object(r.kh)([l,d],this.inputSize):[l/this.inputSizeData[0],d/this.inputSizeData[1]];const h=[];for(let t=0;t<c.length;t++){const s=c[t],p=Object(r.M)((()=>{const p=gt(s instanceof r.ac?s:Object(o.F)(s));if(!a)return p;const m=u[t];let c;return c=e?this.anchors.slice([m,0],[1,2]):this.anchorsData[m],{box:p,landmarks:Object(r.pb)(n,[m,5],[1,-1]).squeeze().reshape([6,-1]),probability:Object(r.pb)(i,[m],[1]),anchor:c}}));h.push(p)}return s.dispose(),i.dispose(),n.dispose(),{boxes:h,scaleFactor:y}}async estimateFaces(t,e=!1,a=!1,n=!0){const[,s]=function(t){return t instanceof r.ac?[t.shape[0],t.shape[1]]:[t.height,t.width]}(t),i=Object(r.M)((()=>(t instanceof r.ac||(t=Object(o.a)(t)),t.toFloat().expandDims(0)))),{boxes:p,scaleFactor:m}=await this.getBoundingBoxes(i,e,n);return i.dispose(),e?p.map((t=>{const e=xt(t,m);let r={topLeft:e.slice([0],[2]),bottomRight:e.slice([2],[2])};if(n){const{landmarks:e,probability:a,anchor:n}=t,s=e.add(n).mul(m);r.landmarks=s,r.probability=a}return a&&(r=Ot(r,s)),r})):Promise.all(p.map((async t=>{const e=xt(t,m);let r;if(n){const[a,n,s]=await Promise.all([t.landmarks,e,t.probability].map((async t=>t.array()))),o=t.anchor,[i,p]=m,u=a.map((t=>[(t[0]+o[0])*i,(t[1]+o[1])*p]));r={topLeft:n.slice(0,2),bottomRight:n.slice(2),landmarks:u,probability:s},(t=>{t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose()})(t.box),t.landmarks.dispose(),t.probability.dispose()}else{const t=await e.array();r={topLeft:t.slice(0,2),bottomRight:t.slice(2)}}return e.dispose(),a&&(r=Ot(r,s)),r})))}}async function wt({maxFaces:t=10,inputWidth:e=128,inputHeight:a=128,iouThreshold:n=.3,scoreThreshold:s=.75}={}){const r=await yt("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0});return new Tt(r,e,a,t,n,s)}var _t={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function St(t){return[Math.abs(t.endPoint[0]-t.startPoint[0]),Math.abs(t.endPoint[1]-t.startPoint[1])]}function jt(t){return[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])/2,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])/2]}function vt(t,e){void 0===e&&(e=1.5);var a=jt(t),n=St(t),s=[e*n[0]/2,e*n[1]/2];return{startPoint:[a[0]-s[0],a[1]-s[1]],endPoint:[a[0]+s[0],a[1]+s[1]],landmarks:t.landmarks}}var Et=[[1,0,0],[0,1,0],[0,0,1]];function Mt(t,e){return[[1,0,t],[0,1,e],[0,0,1]]}function It(t,e){for(var a=0,n=0;n<t.length;n++)a+=t[n]*e[n];return a}function At(t,e){for(var a=[],n=0;n<t.length;n++)a.push(t[n][e]);return a}function Dt(t,e){for(var a=[],n=t.length,s=0;s<n;s++){a.push([]);for(var r=0;r<n;r++)a[s].push(It(t[s],At(e,r)))}return a}function kt(t,e){var a=Math.cos(t),n=Math.sin(t),s=[[a,-n,0],[n,a,0],[0,0,1]],r=Dt(Mt(e[0],e[1]),s);return Dt(r,Mt(-e[0],-e[1]))}var Lt=[13,_t.midwayBetweenEyes[0]],Vt=[3,2],Ct=_t.leftEyeLower0,Pt=[Ct[0],Ct[Ct.length-1]],zt=_t.rightEyeLower0,Ft=[zt[0],zt[zt.length-1]],$t=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]},{key:"EyebrowUpper",indices:[63,64,65,66,67,68,69,70]},{key:"EyebrowLower",indices:[48,49,50,51,52,53]}];function Rt(t,e,a,n){for(var s=0;s<$t.length;s++){var r=$t[s],o=r.key,i=r.indices,p=_t[""+a+o];if(null==n||n.includes(o))for(var m=0;m<i.length;m++){var u=i[m];t[p[m]]=[e[u][0],e[u][1],(e[u][2]+t[p[m]][2])/2]}}}var Bt=function(){function t(t,e,a,n,s,r,o){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=t,this.meshDetector=e,this.irisModel=o,this.meshWidth=a,this.meshHeight=n,this.maxContinuousChecks=s,this.maxFaces=r}return t.prototype.transformRawCoords=function(t,e,a,n){var s,r,o,i,p=this,m=St({startPoint:e.startPoint,endPoint:e.endPoint}),u=[m[0]/this.meshWidth,m[1]/this.meshHeight],c=t.map((function(t){return[u[0]*(t[0]-p.meshWidth/2),u[1]*(t[1]-p.meshHeight/2),t[2]]})),d=kt(a,[0,0]),l=c.map((function(t){return function(t,e){return[It(t,e[0]),It(t,e[1])]}(t,d).concat([t[2]])})),y=(r=[[(s=n)[0][0],s[1][0]],[s[0][1],s[1][1]]],o=[s[0][2],s[1][2]],i=[-It(r[0],o),-It(r[1],o)],[r[0].concat(i[0]),r[1].concat(i[1]),[0,0,1]]),h=jt({startPoint:e.startPoint,endPoint:e.endPoint}).concat([1]),f=[It(h,y[0]),It(h,y[1])];return l.map((function(t){return[t[0]+f[0],t[1]+f[1],t[2]]}))},t.prototype.getLeftToRightEyeDepthDifference=function(t){return t[Pt[0]][2]-t[Ft[0]][2]},t.prototype.getEyeBox=function(t,e,a,n,s){void 0===s&&(s=!1);var r=function(t){var e=jt(t),a=St(t),n=Math.max.apply(Math,a)/2;return{startPoint:[e[0]-n,e[1]-n],endPoint:[e[0]+n,e[1]+n],landmarks:t.landmarks}}(vt(this.calculateLandmarksBoundingBox([t[a],t[n]]),2.3)),i=St(r),p=o.q.cropAndResize(e,[[r.startPoint[1]/this.meshHeight,r.startPoint[0]/this.meshWidth,r.endPoint[1]/this.meshHeight,r.endPoint[0]/this.meshWidth]],[0],[64,64]);return s&&(p=o.q.flipLeftRight(p)),{box:r,boxSize:i,crop:p}},t.prototype.getEyeCoords=function(t,e,a,n){void 0===n&&(n=!1);for(var s=[],r=0;r<76;r++){var o=t[3*r],i=t[3*r+1],p=t[3*r+2];s.push([(n?1-o/64:o/64)*a[0]+e.startPoint[0],i/64*a[1]+e.startPoint[1],p])}return{rawCoords:s,iris:s.slice(71)}},t.prototype.getAdjustedIrisCoords=function(t,e,a){var n=t[_t[a+"EyeUpper0"][3]][2],s=t[_t[a+"EyeLower0"][4]][2],r=(n+s)/2;return e.map((function(t,e){var a=r;return 2===e?a=n:4===e&&(a=s),[t[0],t[1],a]}))},t.prototype.predict=function(t,e){return ft(this,void 0,void 0,(function(){var a,n,s,i,p=this;return bt(this,(function(m){switch(m.label){case 0:return this.shouldUpdateRegionsOfInterest()?[4,this.boundingBoxDetector.getBoundingBoxes(t,!1,!0)]:[3,2];case 1:return a=m.sent(),n=a.boxes,s=a.scaleFactor,0===n.length?(this.regionsOfInterest=[],[2,null]):(i=n.map((function(t){var e,a,n={startPoint:t.box.startPoint.squeeze().arraySync(),endPoint:t.box.endPoint.squeeze().arraySync()},r=vt((a=s,{startPoint:[(e=n).startPoint[0]*a[0],e.startPoint[1]*a[1]],endPoint:[e.endPoint[0]*a[0],e.endPoint[1]*a[1]]}));return ht({},r,{landmarks:t.landmarks.arraySync()})})),n.forEach((function(t){null!=t&&null!=t.startPoint&&(t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose())})),this.updateRegionsOfInterest(i),this.runsWithoutFaceDetector=0,[3,3]);case 2:this.runsWithoutFaceDetector++,m.label=3;case 3:return[2,Object(r.M)((function(){return p.regionsOfInterest.map((function(a,n){var s,i=a.landmarks.length>=468,m=Lt[0],u=Lt[1];!1===i&&(m=Vt[0],u=Vt[1]),s=function(t,e){var a;return(a=Math.PI/2-Math.atan2(-(e[1]-t[1]),e[0]-t[0]))-2*Math.PI*Math.floor((a+Math.PI)/(2*Math.PI))}(a.landmarks[m],a.landmarks[u]);var c=jt({startPoint:a.startPoint,endPoint:a.endPoint}),d=[c[0]/t.shape[2],c[1]/t.shape[1]],l=t,y=Et;0!==s&&(l=o.q.rotateWithOffset(t,s,0,d),y=kt(-s,c));var h=function(t,e,a){var n=e.shape[1],s=e.shape[2],r=[[t.startPoint[1]/n,t.startPoint[0]/s,t.endPoint[1]/n,t.endPoint[0]/s]];return o.q.cropAndResize(e,r,[0],a)}({startPoint:a.startPoint,endPoint:a.endPoint},l,[p.meshHeight,p.meshWidth]).div(255),f=p.meshDetector.predict(h),b=f[1],g=f[2],N=Object(r.N)(g,[-1,3]).arraySync();if(e){var O=p.getEyeBox(N,h,Pt[0],Pt[1],!0),x=O.box,T=O.boxSize,w=O.crop,_=p.getEyeBox(N,h,Ft[0],Ft[1]),S=_.box,j=_.boxSize,v=_.crop,E=p.irisModel.predict(Object(r.K)([w,v])).dataSync(),M=E.slice(0,228),I=p.getEyeCoords(M,x,T,!0),A=I.rawCoords,D=I.iris,k=E.slice(228),L=p.getEyeCoords(k,S,j),V=L.rawCoords,C=L.iris,P=p.getLeftToRightEyeDepthDifference(N);Math.abs(P)<30?(Rt(N,A,"left"),Rt(N,V,"right")):P<1?Rt(N,A,"left",["EyeUpper0","EyeLower0"]):Rt(N,V,"right",["EyeUpper0","EyeLower0"]);var z=p.getAdjustedIrisCoords(N,D,"left"),F=p.getAdjustedIrisCoords(N,C,"right");N=N.concat(z).concat(F)}var $=p.transformRawCoords(N,a,s,y),R=Object(o.F)($),B=vt(p.calculateLandmarksBoundingBox($));return p.regionsOfInterest[n]=ht({},B,{landmarks:R.arraySync()}),{coords:Object(o.F)(N,[N.length,3]),scaledCoords:R,box:B,flag:b.squeeze()}}))}))]}}))}))},t.prototype.updateRegionsOfInterest=function(t){for(var e=0;e<t.length;e++){var a=t[e],n=this.regionsOfInterest[e],s=0;if(n&&n.startPoint){var r=a.startPoint,o=r[0],i=r[1],p=a.endPoint,m=p[0],u=p[1],c=n.startPoint,d=c[0],l=c[1],y=n.endPoint,h=y[0],f=y[1],b=Math.max(o,d),g=Math.max(i,l),N=(Math.min(m,h)-b)*(Math.min(u,f)-g);s=N/((m-o)*(u-i)+(h-d)*(f-i)-N)}s<.25&&(this.regionsOfInterest[e]=a)}this.regionsOfInterest=this.regionsOfInterest.slice(0,t.length)},t.prototype.clearRegionOfInterest=function(t){null!=this.regionsOfInterest[t]&&(this.regionsOfInterest=this.regionsOfInterest.slice(0,t).concat(this.regionsOfInterest.slice(t+1)))},t.prototype.shouldUpdateRegionsOfInterest=function(){var t=this.regionsOfInterest.length,e=0===t;return 1===this.maxFaces||e?e:t!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks},t.prototype.calculateLandmarksBoundingBox=function(t){var e=t.map((function(t){return t[0]})),a=t.map((function(t){return t[1]}));return{startPoint:[Math.min.apply(Math,e),Math.min.apply(Math,a)],endPoint:[Math.max.apply(Math,e),Math.max.apply(Math,a)]}},t}(),Ht=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]];function Ut(t){return ft(this,void 0,void 0,(function(){var e,a,n,s,r,o,i,p,m,u,c,d,l,y,h;return bt(this,(function(f){switch(f.label){case 0:return e=t.maxContinuousChecks,a=void 0===e?5:e,n=t.detectionConfidence,s=void 0===n?.9:n,r=t.maxFaces,o=void 0===r?10:r,i=t.iouThreshold,p=void 0===i?.3:i,m=t.scoreThreshold,u=void 0===m?.75:m,c=t.shouldLoadIrisModel,d=void 0===c||c,l=t.modelUrl,y=t.irisModelUrl,d?[4,Promise.all([Wt(o,p,u),qt(l),Gt(y)])]:[3,2];case 1:return h=f.sent(),[3,4];case 2:return[4,Promise.all([Wt(o,p,u),qt(l)])];case 3:h=f.sent(),f.label=4;case 4:return[2,new Jt(h[0],h[1],a,s,o,d?h[2]:null)]}}))}))}function Wt(t,e,a){return ft(this,void 0,void 0,(function(){return bt(this,(function(n){return[2,wt({maxFaces:t,iouThreshold:e,scoreThreshold:a})]}))}))}function qt(t){return ft(this,void 0,void 0,(function(){return bt(this,(function(e){return null!=t?[2,yt(t)]:[2,yt("https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",{fromTFHub:!0})]}))}))}function Gt(t){return ft(this,void 0,void 0,(function(){return bt(this,(function(e){return null!=t?[2,yt(t)]:[2,yt("https://tfhub.dev/mediapipe/tfjs-model/iris/1/default/2",{fromTFHub:!0})]}))}))}function Kt(t,e){if(t.mesh instanceof r.ac){var a=Object(r.M)((function(){var a=Object(o.r)([e-1,0,0]),n=Object(o.r)([1,-1,1]);return Object(r.M)((function(){return[Object(r.K)([Object(r.Pb)(e-1,t.boundingBox.topLeft.slice(0,1)),t.boundingBox.topLeft.slice(1,1)]),Object(r.K)([Object(r.Pb)(e-1,t.boundingBox.bottomRight.slice(0,1)),t.boundingBox.bottomRight.slice(1,1)]),Object(r.Pb)(a,t.mesh).mul(n),Object(r.Pb)(a,t.scaledMesh).mul(n)]}))})),n=a[0],s=a[1],i=a[2],p=a[3];return Object.assign({},t,{boundingBox:{topLeft:n,bottomRight:s},mesh:i,scaledMesh:p})}return Object.assign({},t,{boundingBox:{topLeft:[e-1-t.boundingBox.topLeft[0],t.boundingBox.topLeft[1]],bottomRight:[e-1-t.boundingBox.bottomRight[0],t.boundingBox.bottomRight[1]]},mesh:t.mesh.map((function(t){var a=t.slice(0);return a[0]=e-1-t[0],a})),scaledMesh:t.scaledMesh.map((function(t){var a=t.slice(0);return a[0]=e-1-t[0],a}))})}var Qt,Jt=function(){function t(t,e,a,n,s,r){this.kind="MediaPipeFaceMesh",this.pipeline=new Bt(t,e,192,192,a,s,r),this.detectionConfidence=n}return t.getAnnotations=function(){return _t},t.getUVCoords=function(){return Ht},t.prototype.estimateFaces=function(t){return ft(this,void 0,void 0,(function(){var e,a,n,s,i,p,m,u,c,d,l,y,h=this;return bt(this,(function(f){switch(f.label){case 0:if(e=t.returnTensors,a=void 0!==e&&e,n=t.flipHorizontal,s=void 0!==n&&n,i=t.predictIrises,p=void 0===i||i,m=t.input,p&&null==this.pipeline.irisModel)throw new Error("The iris model was not loaded as part of facemesh. Please initialize the model with facemesh.load({shouldLoadIrisModel: true}).");return u=function(t){return t instanceof r.ac?[t.shape[0],t.shape[1]]:[t.height,t.width]}(m),c=u[1],d=Object(r.M)((function(){return m instanceof r.ac||(m=Object(o.a)(m)),m.toFloat().expandDims(0)})),"webgl"!==Object(r.Cc)()?[3,2]:(y=Object(r.Bf)().get("WEBGL_PACK_DEPTHWISECONV"),Object(r.Bf)().set("WEBGL_PACK_DEPTHWISECONV",!0),[4,this.pipeline.predict(d,p)]);case 1:return l=f.sent(),Object(r.Bf)().set("WEBGL_PACK_DEPTHWISECONV",y),[3,4];case 2:return[4,this.pipeline.predict(d,p)];case 3:l=f.sent(),f.label=4;case 4:return d.dispose(),null!=l&&l.length>0?[2,Promise.all(l.map((function(t,e){return ft(h,void 0,void 0,(function(){var n,r,i,m,u,d,l,y,h,f,b,g,N,O,x=this;return bt(this,(function(T){switch(T.label){case 0:return n=t.coords,r=t.scaledCoords,i=t.box,m=t.flag,u=[m],a||(u=u.concat([n,r])),[4,Promise.all(u.map((function(t){return ft(x,void 0,void 0,(function(){return bt(this,(function(e){return[2,t.array()]}))}))})))];case 1:if(d=T.sent(),l=d[0],m.dispose(),l<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(e),a)return y={kind:"MediaPipePredictionTensors",faceInViewConfidence:l,mesh:n,scaledMesh:r,boundingBox:{topLeft:Object(o.r)(i.startPoint),bottomRight:Object(o.r)(i.endPoint)}},s?[2,Kt(y,c)]:[2,y];for(O in h=d.slice(1),f=h[0],b=h[1],r.dispose(),n.dispose(),g={kind:"MediaPipePredictionValues",faceInViewConfidence:l,boundingBox:{topLeft:i.startPoint,bottomRight:i.endPoint},mesh:f,scaledMesh:b},s&&(g=Kt(g,c)),N={},_t)(p||!1===O.includes("Iris"))&&(N[O]=_t[O].map((function(t){return g.scaledMesh[t]})));return g.annotations=N,[2,g]}}))}))})))]:[2,[]]}}))}))},t}();function Xt(t,e){return void 0===t&&(t=Qt.mediapipeFacemesh),void 0===e&&(e={}),ft(this,void 0,void 0,(function(){return bt(this,(function(a){if(t===Qt.mediapipeFacemesh)return[2,Ut(e)];throw new Error(t+" is not a valid package name.")}))}))}(Qt||(Qt={})).mediapipeFacemesh="mediapipe-facemesh"}).call(this,a(70).Buffer)}}]);