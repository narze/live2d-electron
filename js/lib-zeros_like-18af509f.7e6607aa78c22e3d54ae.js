/*! For license information please see lib-zeros_like-18af509f.7e6607aa78c22e3d54ae.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[9],[function(t,e,n){"use strict";(function(t,r){n.d(e,"a",(function(){return Js})),n.d(e,"b",(function(){return hu})),n.d(e,"c",(function(){return du})),n.d(e,"d",(function(){return vi})),n.d(e,"e",(function(){return cu})),n.d(e,"f",(function(){return iu})),n.d(e,"g",(function(){return ru})),n.d(e,"h",(function(){return eu})),n.d(e,"i",(function(){return nu})),n.d(e,"j",(function(){return ya})),n.d(e,"k",(function(){return sa})),n.d(e,"l",(function(){return fa})),n.d(e,"m",(function(){return pa})),n.d(e,"n",(function(){return ea})),n.d(e,"o",(function(){return Qi})),n.d(e,"p",(function(){return Yi})),n.d(e,"q",(function(){return Xi})),n.d(e,"r",(function(){return Ji})),n.d(e,"s",(function(){return Ri})),n.d(e,"t",(function(){return Ci})),n.d(e,"u",(function(){return fo})),n.d(e,"v",(function(){return Ni})),n.d(e,"w",(function(){return si})),n.d(e,"x",(function(){return oi})),n.d(e,"y",(function(){return ri})),n.d(e,"z",(function(){return ni})),n.d(e,"A",(function(){return ei})),n.d(e,"B",(function(){return Xs})),n.d(e,"C",(function(){return qa})),n.d(e,"D",(function(){return Ki})),n.d(e,"E",(function(){return Vs})),n.d(e,"F",(function(){return C})),n.d(e,"G",(function(){return uu})),n.d(e,"H",(function(){return Ls})),n.d(e,"I",(function(){return mo})),n.d(e,"J",(function(){return Su})),n.d(e,"K",(function(){return xi})),n.d(e,"L",(function(){return Fu})),n.d(e,"M",(function(){return Ks})),n.d(e,"N",(function(){return wi})),n.d(e,"O",(function(){return gs})),n.d(e,"P",(function(){return ps})),n.d(e,"Q",(function(){return Sa})),n.d(e,"R",(function(){return fu})),n.d(e,"S",(function(){return da})),n.d(e,"T",(function(){return Di})),n.d(e,"U",(function(){return Pi})),n.d(e,"V",(function(){return ti})),n.d(e,"W",(function(){return Qs})),n.d(e,"X",(function(){return Zs})),n.d(e,"Y",(function(){return Ys})),n.d(e,"Z",(function(){return va})),n.d(e,"ab",(function(){return La})),n.d(e,"bb",(function(){return za})),n.d(e,"cb",(function(){return ka})),n.d(e,"db",(function(){return bu})),n.d(e,"eb",(function(){return ta})),n.d(e,"fb",(function(){return vu})),n.d(e,"gb",(function(){return L})),n.d(e,"hb",(function(){return Eu})),n.d(e,"ib",(function(){return su})),n.d(e,"jb",(function(){return na})),n.d(e,"kb",(function(){return yu})),n.d(e,"lb",(function(){return wu})),n.d(e,"mb",(function(){return mu})),n.d(e,"nb",(function(){return gu})),n.d(e,"ob",(function(){return $i})),n.d(e,"pb",(function(){return Si})),n.d(e,"qb",(function(){return Li})),n.d(e,"rb",(function(){return Pa})),n.d(e,"sb",(function(){return ki})),n.d(e,"tb",(function(){return zi})),n.d(e,"ub",(function(){return Mi})),n.d(e,"vb",(function(){return Fi})),n.d(e,"wb",(function(){return Ai})),n.d(e,"xb",(function(){return Hi})),n.d(e,"yb",(function(){return Ha})),n.d(e,"zb",(function(){return Va})),n.d(e,"Ab",(function(){return ja})),n.d(e,"Bb",(function(){return fs})),n.d(e,"Cb",(function(){return hs})),n.d(e,"Db",(function(){return Nu})),n.d(e,"Eb",(function(){return $u})),n.d(e,"Fb",(function(){return Wi})),n.d(e,"Gb",(function(){return Ca})),n.d(e,"Hb",(function(){return Ba})),n.d(e,"Ib",(function(){return Ma})),n.d(e,"Jb",(function(){return ha})),n.d(e,"Kb",(function(){return la})),n.d(e,"Lb",(function(){return oa})),n.d(e,"Mb",(function(){return ra})),n.d(e,"Nb",(function(){return Wa})),n.d(e,"Ob",(function(){return Ui})),n.d(e,"Pb",(function(){return xa})),n.d(e,"Qb",(function(){return hr})),n.d(e,"Rb",(function(){return Ei})),n.d(e,"Sb",(function(){return Xa})),n.d(e,"Tb",(function(){return Ja})),n.d(e,"Ub",(function(){return Oa})),n.d(e,"Vb",(function(){return Zi})),n.d(e,"Wb",(function(){return mt})),n.d(e,"Xb",(function(){return Ao})),n.d(e,"Yb",(function(){return wo})),n.d(e,"Zb",(function(){return Fo})),n.d(e,"ac",(function(){return zr})),n.d(e,"bc",(function(){return en})),n.d(e,"cc",(function(){return un})),n.d(e,"dc",(function(){return vn})),n.d(e,"ec",(function(){return Rr})),n.d(e,"fc",(function(){return Au})),n.d(e,"gc",(function(){return ys})),n.d(e,"hc",(function(){return Cn})),n.d(e,"ic",(function(){return Zn})),n.d(e,"jc",(function(){return Te})),n.d(e,"kc",(function(){return Qu})),n.d(e,"lc",(function(){return Zu})),n.d(e,"mc",(function(){return ci})),n.d(e,"nc",(function(){return Jr})),n.d(e,"oc",(function(){return Gi})),n.d(e,"pc",(function(){return ma})),n.d(e,"qc",(function(){return pr})),n.d(e,"rc",(function(){return Xu})),n.d(e,"sc",(function(){return mi})),n.d(e,"tc",(function(){return _i})),n.d(e,"uc",(function(){return Ju})),n.d(e,"vc",(function(){return Yu})),n.d(e,"wc",(function(){return fr})),n.d(e,"xc",(function(){return ec})),n.d(e,"yc",(function(){return tc})),n.d(e,"zc",(function(){return dr})),n.d(e,"Ac",(function(){return ie})),n.d(e,"Bc",(function(){return Ie})),n.d(e,"Cc",(function(){return Os})),n.d(e,"Dc",(function(){return yo})),n.d(e,"Ec",(function(){return z})),n.d(e,"Fc",(function(){return $o})),n.d(e,"Gc",(function(){return Eo})),n.d(e,"Hc",(function(){return So})),n.d(e,"Ic",(function(){return P})),n.d(e,"Jc",(function(){return ao})),n.d(e,"Kc",(function(){return go})),n.d(e,"Lc",(function(){return lo})),n.d(e,"Mc",(function(){return po})),n.d(e,"Nc",(function(){return yr})),n.d(e,"Oc",(function(){return no})),n.d(e,"Pc",(function(){return lr})),n.d(e,"Qc",(function(){return Nt})),n.d(e,"Rc",(function(){return Rs})),n.d(e,"Sc",(function(){return yi})),n.d(e,"Tc",(function(){return q})),n.d(e,"Uc",(function(){return Lt})),n.d(e,"Vc",(function(){return Ut})),n.d(e,"Wc",(function(){return te})),n.d(e,"Xc",(function(){return ae})),n.d(e,"Yc",(function(){return ls})),n.d(e,"Zc",(function(){return Se})),n.d(e,"ad",(function(){return qe})),n.d(e,"bd",(function(){return Qe})),n.d(e,"cd",(function(){return ds})),n.d(e,"dd",(function(){return At})),n.d(e,"ed",(function(){return dn})),n.d(e,"fd",(function(){return oc})),n.d(e,"gd",(function(){return fn})),n.d(e,"hd",(function(){return ic})),n.d(e,"id",(function(){return pn})),n.d(e,"jd",(function(){return sc})),n.d(e,"kd",(function(){return Vu})),n.d(e,"ld",(function(){return zs})),n.d(e,"md",(function(){return R})),n.d(e,"nd",(function(){return _a})),n.d(e,"od",(function(){return $r})),n.d(e,"pd",(function(){return K})),n.d(e,"qd",(function(){return B})),n.d(e,"rd",(function(){return nt})),n.d(e,"sd",(function(){return Dr})),n.d(e,"td",(function(){return tt})),n.d(e,"ud",(function(){return so})),n.d(e,"vd",(function(){return Gs})),n.d(e,"wd",(function(){return _e})),n.d(e,"xd",(function(){return Vt})),n.d(e,"yd",(function(){return Ke})),n.d(e,"zd",(function(){return kn})),n.d(e,"Ad",(function(){return cn})),n.d(e,"Bd",(function(){return Dn})),n.d(e,"Cd",(function(){return W})),n.d(e,"Dd",(function(){return Ta})),n.d(e,"Ed",(function(){return Aa})),n.d(e,"Fd",(function(){return Na})),n.d(e,"Gd",(function(){return Vr})),n.d(e,"Hd",(function(){return Wn})),n.d(e,"Id",(function(){return or})),n.d(e,"Jd",(function(){return It})),n.d(e,"Kd",(function(){return Et})),n.d(e,"Ld",(function(){return Dt})),n.d(e,"Md",(function(){return $t})),n.d(e,"Nd",(function(){return Tt})),n.d(e,"Od",(function(){return Ft})),n.d(e,"Pd",(function(){return $a})),n.d(e,"Qd",(function(){return dc})),n.d(e,"Rd",(function(){return hc})),n.d(e,"Sd",(function(){return O})),n.d(e,"Td",(function(){return G})),n.d(e,"Ud",(function(){return M})),n.d(e,"Vd",(function(){return j})),n.d(e,"Wd",(function(){return oo})),n.d(e,"Xd",(function(){return ut})),n.d(e,"Yd",(function(){return U})),n.d(e,"Zd",(function(){return V})),n.d(e,"ae",(function(){return qi})),n.d(e,"be",(function(){return gt})),n.d(e,"ce",(function(){return ft})),n.d(e,"de",(function(){return dt})),n.d(e,"ee",(function(){return J})),n.d(e,"fe",(function(){return Sr})),n.d(e,"ge",(function(){return Da})),n.d(e,"he",(function(){return jr})),n.d(e,"ie",(function(){return As})),n.d(e,"je",(function(){return _s})),n.d(e,"ke",(function(){return H})),n.d(e,"le",(function(){return F})),n.d(e,"me",(function(){return T})),n.d(e,"ne",(function(){return Ps})),n.d(e,"oe",(function(){return Er})),n.d(e,"pe",(function(){return ji})),n.d(e,"qe",(function(){return ze})),n.d(e,"re",(function(){return _t})),n.d(e,"se",(function(){return Mt})),n.d(e,"te",(function(){return Bt})),n.d(e,"ue",(function(){return Ct})),n.d(e,"ve",(function(){return Pt})),n.d(e,"we",(function(){return Rt})),n.d(e,"xe",(function(){return Kt})),n.d(e,"ye",(function(){return ai})),n.d(e,"ze",(function(){return ui})),n.d(e,"Ae",(function(){return qt})),n.d(e,"Be",(function(){return se})),n.d(e,"Ce",(function(){return Fa})),n.d(e,"De",(function(){return ue})),n.d(e,"Ee",(function(){return ce})),n.d(e,"Fe",(function(){return le})),n.d(e,"Ge",(function(){return he})),n.d(e,"He",(function(){return de})),n.d(e,"Ie",(function(){return pe})),n.d(e,"Je",(function(){return ii})),n.d(e,"Ke",(function(){return ge})),n.d(e,"Le",(function(){return me})),n.d(e,"Me",(function(){return be})),n.d(e,"Ne",(function(){return ye})),n.d(e,"Oe",(function(){return we})),n.d(e,"Pe",(function(){return ke})),n.d(e,"Qe",(function(){return xe})),n.d(e,"Re",(function(){return ve})),n.d(e,"Se",(function(){return st})),n.d(e,"Te",(function(){return Ee})),n.d(e,"Ue",(function(){return De})),n.d(e,"Ve",(function(){return Ne})),n.d(e,"We",(function(){return Fe})),n.d(e,"Xe",(function(){return Ae})),n.d(e,"Ye",(function(){return Me})),n.d(e,"Ze",(function(){return Ce})),n.d(e,"af",(function(){return Re})),n.d(e,"bf",(function(){return Pe})),n.d(e,"cf",(function(){return zt})),n.d(e,"df",(function(){return Ot})),n.d(e,"ef",(function(){return $e})),n.d(e,"ff",(function(){return Kn})),n.d(e,"gf",(function(){return Ms})),n.d(e,"hf",(function(){return ws})),n.d(e,"if",(function(){return Gt})),n.d(e,"jf",(function(){return hn})),n.d(e,"kf",(function(){return Sn})),n.d(e,"lf",(function(){return Wt})),n.d(e,"mf",(function(){return Z})),n.d(e,"nf",(function(){return Ht})),n.d(e,"of",(function(){return jt})),n.d(e,"pf",(function(){return Jt})),n.d(e,"qf",(function(){return Be})),n.d(e,"rf",(function(){return Xt})),n.d(e,"sf",(function(){return Yt})),n.d(e,"tf",(function(){return bi})),n.d(e,"uf",(function(){return Zt})),n.d(e,"vf",(function(){return Qt})),n.d(e,"wf",(function(){return li})),n.d(e,"xf",(function(){return ee})),n.d(e,"yf",(function(){return ne})),n.d(e,"zf",(function(){return re})),n.d(e,"Af",(function(){return oe})),n.d(e,"Bf",(function(){return wt})),n.d(e,"Cf",(function(){return ar})),n.d(e,"Df",(function(){return Le})),n.d(e,"Ef",(function(){return Oe})),n.d(e,"Ff",(function(){return Ge})),n.d(e,"Gf",(function(){return Ue})),n.d(e,"Hf",(function(){return We})),n.d(e,"If",(function(){return He})),n.d(e,"Jf",(function(){return je})),n.d(e,"Kf",(function(){return Ve})),n.d(e,"Lf",(function(){return Je})),n.d(e,"Mf",(function(){return Xe})),n.d(e,"Nf",(function(){return _n})),n.d(e,"Of",(function(){return Mn})),n.d(e,"Pf",(function(){return Bn})),n.d(e,"Qf",(function(){return bs})),n.d(e,"Rf",(function(){return Rn})),n.d(e,"Sf",(function(){return Pn})),n.d(e,"Tf",(function(){return pc})),n.d(e,"Uf",(function(){return fc})),n.d(e,"Vf",(function(){return On})),n.d(e,"Wf",(function(){return qn})),n.d(e,"Xf",(function(){return zn})),n.d(e,"Yf",(function(){return Ln})),n.d(e,"Zf",(function(){return Gn})),n.d(e,"ag",(function(){return Hn})),n.d(e,"bg",(function(){return jn})),n.d(e,"cg",(function(){return Un})),n.d(e,"dg",(function(){return Xn})),n.d(e,"eg",(function(){return Jn})),n.d(e,"fg",(function(){return cr})),n.d(e,"gg",(function(){return Qn})),n.d(e,"hg",(function(){return Bs})),n.d(e,"ig",(function(){return tr})),n.d(e,"jg",(function(){return er})),n.d(e,"kg",(function(){return nr})),n.d(e,"lg",(function(){return rr})),n.d(e,"mg",(function(){return sr})),n.d(e,"ng",(function(){return ir})),n.d(e,"og",(function(){return Ye})),n.d(e,"pg",(function(){return tn})),n.d(e,"qg",(function(){return Ze})),n.d(e,"rg",(function(){return nn})),n.d(e,"sg",(function(){return rn})),n.d(e,"tg",(function(){return on})),n.d(e,"ug",(function(){return sn})),n.d(e,"vg",(function(){return an})),n.d(e,"wg",(function(){return fe})),n.d(e,"xg",(function(){return Yn})),n.d(e,"yg",(function(){return Vn})),n.d(e,"zg",(function(){return ln})),n.d(e,"Ag",(function(){return mn})),n.d(e,"Bg",(function(){return ur})),n.d(e,"Cg",(function(){return gn})),n.d(e,"Dg",(function(){return yn})),n.d(e,"Eg",(function(){return bn})),n.d(e,"Fg",(function(){return wn})),n.d(e,"Gg",(function(){return xn})),n.d(e,"Hg",(function(){return In})),n.d(e,"Ig",(function(){return En})),n.d(e,"Jg",(function(){return An})),n.d(e,"Kg",(function(){return Tn})),n.d(e,"Lg",(function(){return Fn})),n.d(e,"Mg",(function(){return $n})),n.d(e,"Ng",(function(){return Nn})),n.d(e,"Og",(function(){return Ws})),n.d(e,"Pg",(function(){return kr})),n.d(e,"Qg",(function(){return at})),n.d(e,"Rg",(function(){return Cs})),n.d(e,"Sg",(function(){return Ia})),n.d(e,"Tg",(function(){return Ea})),n.d(e,"Ug",(function(){return Oi})),n.d(e,"Vg",(function(){return hi})),n.d(e,"Wg",(function(){return ms})),n.d(e,"Xg",(function(){return Io})),n.d(e,"Yg",(function(){return bo})),n.d(e,"Zg",(function(){return To})),n.d(e,"ah",(function(){return No})),n.d(e,"bh",(function(){return os})),n.d(e,"ch",(function(){return ns})),n.d(e,"dh",(function(){return ss})),n.d(e,"eh",(function(){return rs})),n.d(e,"fh",(function(){return Q})),n.d(e,"gh",(function(){return Bi})),n.d(e,"hh",(function(){return ho})),n.d(e,"ih",(function(){return Xr})),n.d(e,"jh",(function(){return ga})),n.d(e,"kh",(function(){return Hs})),n.d(e,"lh",(function(){return qs})),n.d(e,"mh",(function(){return js})),n.d(e,"nh",(function(){return Ga})),n.d(e,"oh",(function(){return Us})),n.d(e,"ph",(function(){return Qa})),n.d(e,"qh",(function(){return ca})),n.d(e,"rh",(function(){return Ka})),n.d(e,"sh",(function(){return tu})),n.d(e,"th",(function(){return ou})),n.d(e,"uh",(function(){return Za})),n.d(e,"vh",(function(){return Ti})),n.d(e,"wh",(function(){return au})),n.d(e,"xh",(function(){return xu})),n.d(e,"yh",(function(){return lt})),n.d(e,"zh",(function(){return Du})),n.d(e,"Ah",(function(){return Ii})),n.d(e,"Bh",(function(){return Ua})),n.d(e,"Ch",(function(){return ku})),n.d(e,"Dh",(function(){return ba})),n.d(e,"Eh",(function(){return pu}));n(35),n(18),n(20),n(28),n(25),n(31),n(39),n(8);function o(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}var i,a=o,u=s;function c(t){if(a===setTimeout)return setTimeout(t,0);if((a===o||!a)&&setTimeout)return a=setTimeout,setTimeout(t,0);try{return a(t,0)}catch(e){try{return a.call(null,t,0)}catch(e){return a.call(this,t,0)}}}"function"==typeof(i="undefined"!=typeof window?window:"undefined"!=typeof self?self:{}).setTimeout&&(a=setTimeout),"function"==typeof i.clearTimeout&&(u=clearTimeout);var l,h=[],d=!1,p=-1;function f(){d&&l&&(d=!1,l.length?h=l.concat(h):p=-1,h.length&&g())}function g(){if(!d){var t=c(f);d=!0;for(var e=h.length;e;){for(l=h,h=[];++p<e;)l&&l[p].run();p=-1,e=h.length}l=null,d=!1,function(t){if(u===clearTimeout)return clearTimeout(t);if((u===s||!u)&&clearTimeout)return u=clearTimeout,clearTimeout(t);try{u(t)}catch(e){try{return u.call(null,t)}catch(e){return u.call(this,t)}}}(t)}}function m(t,e){this.fun=t,this.array=e}m.prototype.run=function(){this.fun.apply(null,this.array)};function y(){}var b=y,w=y,k=y,x=y,v=y,S=y,I=y;var E=i.performance||{},D=E.now||E.mozNow||E.msNow||E.oNow||E.webkitNow||function(){return(new Date).getTime()};var $=new Date;var N={nextTick:function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];h.push(new m(t,e)),1!==h.length||d||c(g)},title:"browser",browser:!0,env:{NODE_ENV:"production"},argv:[],version:"",versions:{},on:b,addListener:w,once:k,off:x,removeListener:v,removeAllListeners:S,emit:I,binding:function(t){throw new Error("process.binding is not supported")},cwd:function(){return"/"},chdir:function(t){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(t){var e=.001*D.call(E),n=Math.floor(e),r=Math.floor(e%1*1e9);return t&&(n-=t[0],(r-=t[1])<0&&(n--,r+=1e9)),[n,r]},platform:"browser",release:{},config:{},uptime:function(){return(new Date-$)/1e3}};class T{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class F{decComplexRef(t){}time(t){return A("time")}read(t){return A("read")}readSync(t){return A("readSync")}numDataIds(){return A("numDataIds")}disposeData(t){return A("disposeData")}write(t,e,n){return A("write")}move(t,e,n,r){return A("move")}memory(){return A("memory")}floatPrecision(){return A("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(t,e,n,r){return A("batchMatMul")}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:o,activation:s,preluActivationWeights:i}){return A("fusedBatchMatMul")}slice(t,e,n){return A("slice")}stridedSlice(t,e,n,r){return A("stridedSlice")}unstack(t,e){return A("unstack")}reverse(t,e){return A("reverse")}concat(t,e){return A("concat")}neg(t){return A("neg")}add(t,e){return A("add")}addN(t){return A("addN")}subtract(t,e){return A("subtract")}multiply(t,e){return A("multiply")}realDivide(t,e){return A("realDivide")}floorDiv(t,e){return A("floorDiv")}sum(t,e){return A("sum")}prod(t,e){return A("prod")}unsortedSegmentSum(t,e,n){return A("unsortedSegmentSum")}argMin(t,e){return A("argMin")}argMax(t,e){return A("argMax")}equal(t,e){return A("equal")}notEqual(t,e){return A("notEqual")}less(t,e){return A("less")}lessEqual(t,e){return A("lessEqual")}greater(t,e){return A("greater")}greaterEqual(t,e){return A("greaterEqual")}logicalNot(t){return A("logicalNot")}logicalAnd(t,e){return A("logicalAnd")}logicalOr(t,e){return A("logicalOr")}where(t){return A("where")}select(t,e,n){return A("select")}topk(t,e,n){return A("topk")}min(t,e){return A("min")}minimum(t,e){return A("minimum")}mod(t,e){return A("mod")}max(t,e){return A("max")}maximum(t,e){return A("maximum")}all(t,e){return A("all")}any(t,e){return A("any")}squaredDifference(t,e){return A("squaredDifference")}ceil(t){return A("ceil")}floor(t){return A("floor")}round(t){return A("round")}sign(t){return A("sign")}isNaN(t){return A("isNaN")}isInf(t){return A("isInf")}isFinite(t){return A("isFinite")}pow(t,e){return A("pow")}exp(t){return A("exp")}expm1(t){return A("expm1")}softmax(t,e){return A("softmax")}log(t){return A("log")}log1p(t){return A("log1p")}sqrt(t){return A("sqrt")}rsqrt(t){return A("rsqrt")}square(t){return A("square")}reciprocal(t){return A("reciprocal")}relu(t){return A("relu")}relu6(t){return A("relu6")}prelu(t,e){return A("prelu")}elu(t){return A("elu")}eluDer(t,e){return A("eluDer")}selu(t){return A("selu")}int(t){return A("int")}clip(t,e,n){return A("clip")}abs(t){return A("abs")}complexAbs(t){return A("complexAbs")}sigmoid(t){return A("sigmoid")}softplus(t){return A("softplus")}sin(t){return A("sin")}cos(t){return A("cos")}tan(t){return A("tan")}asin(t){return A("asin")}acos(t){return A("acos")}atan(t){return A("atan")}atan2(t,e){return A("atan2")}sinh(t){return A("sinh")}cosh(t){return A("cosh")}tanh(t){return A("tanh")}asinh(t){return A("asinh")}acosh(t){return A("acosh")}atanh(t){return A("atanh")}erf(t){return A("erf")}step(t,e){return A("step")}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:o,preluActivationWeights:s}){return A("fusedConv2d")}conv2d(t,e,n){return A("conv2d")}conv2dDerInput(t,e,n){return A("conv2dDerInput")}conv2dDerFilter(t,e,n){return A("conv2dDerFilter")}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:o,preluActivationWeights:s}){return A("fusedDepthwiseConv2D")}depthwiseConv2D(t,e,n){return A("depthwiseConv2D")}depthwiseConv2DDerInput(t,e,n){return A("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(t,e,n){return A("depthwiseConv2DDerFilter")}conv3d(t,e,n){return A("conv3d")}conv3dDerInput(t,e,n){return A("conv3dDerInput")}conv3dDerFilter(t,e,n){return A("conv3dDerFilter")}maxPool(t,e){return A("maxPool")}maxPoolBackprop(t,e,n,r){return A("maxPoolBackprop")}avgPool(t,e){return A("avgPool")}avgPoolBackprop(t,e,n){return A("avgPoolBackprop")}avgPool3d(t,e){return A("avgPool3d")}avgPool3dBackprop(t,e,n){return A("avgPool3dBackprop")}maxPool3d(t,e){return A("maxPool3d")}maxPool3dBackprop(t,e,n,r){return A("maxPool3dBackprop")}reshape(t,e){return A("reshape")}cast(t,e){return A("cast")}tile(t,e){return A("tile")}pad(t,e,n){return A("pad")}transpose(t,e){return A("transpose")}gather(t,e,n,r=0){return A("gather")}gatherND(t,e){return A("gatherND")}scatterND(t,e,n){return A("scatterND")}batchToSpaceND(t,e,n){return A("batchToSpaceND")}spaceToBatchND(t,e,n){return A("spaceToBatchND")}resizeBilinear(t,e,n,r,o){return A("resizeBilinear")}resizeBilinearBackprop(t,e,n){return A("resizeBilinearBackprop")}resizeNearestNeighbor(t,e,n,r,o){return A("resizeNearestNeighbor")}resizeNearestNeighborBackprop(t,e,n){return A("resizeNearestNeighborBackprop")}batchNorm(t,e,n,r,o,s){return A("batchNorm")}localResponseNormalization4D(t,e,n,r,o){return A("localResponseNormalization4D")}LRNGrad(t,e,n,r,o,s,i){return A("LRNGrad")}multinomial(t,e,n,r){return A("multinomial")}oneHot(t,e,n,r){return A("oneHot")}cumsum(t,e,n,r){return A("cumsum")}nonMaxSuppression(t,e,n,r,o){return A("nonMaxSuppression")}fft(t){return A("fft")}ifft(t){return A("ifft")}complex(t,e){return A("complex")}real(t){return A("real")}imag(t){return A("imag")}cropAndResize(t,e,n,r,o,s){return A("cropAndResize")}depthToSpace(t,e,n){return A("depthToSpace")}split(t,e,n){return A("split")}sparseToDense(t,e,n,r){return A("sparseToDense")}diag(t){return A("diag")}fill(t,e,n){return A("fill")}onesLike(t){return A("onesLike")}zerosLike(t){return A("zerosLike")}linspace(t,e,n){return A("linspace")}dispose(){return A("dispose")}}function A(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function _(t,e,n){return Math.max(t,Math.min(e,n))}function M(t){return t%2==0?t:t+1}function B(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function C(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function R(t,e,n=""){C(L(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}function P(t){C(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function K(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||Q(t)&&!n)for(let r=0;r<t.length;++r)K(t[r],e,n);else e.push(t);return e}function z(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function L(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function q(t){return t%1==0}function O(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function G(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function U(t,e=(t=>0),n){return new Promise(((r,o)=>{let s=0;const i=()=>{if(t())return void r();s++;const a=e(s);null!=n&&s>=n?o():setTimeout(i,a)};i()}))}function W(t,e){let n=1,r=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${e}`);r=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const o=t.slice();return o[r]=e/n,o}function H(t,e){const n=e.length;return C((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),C(t.every((t=>q(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function j(t,e){const n=[],r=[],o=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||o?null:H(e,t).sort();let i=0;for(let e=0;e<t.length;++e){if(null!=s){if(s[i]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==s[i]||s[i]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),s[i]<=e&&i++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function V(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function J(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function X(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Y(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function Z(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function Q(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function tt(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function et(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}function nt(t){return"string"==typeof t||t instanceof String}function rt(t){return"boolean"==typeof t}function ot(t){return"number"==typeof t}function st(t){return Array.isArray(t)?st(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":ot(t)?"float32":nt(t)?"string":rt(t)?"bool":"float32"}function it(t){return!!(t&&t.constructor&&t.call&&t.apply)}function at(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function ut(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function ct(t,e,n){const r=new Array;if(1===e.length){const o=e[0];for(let e=0;e<o;e++)r[e]=n[t+e]}else{const o=e[0],s=e.slice(1),i=s.reduce(((t,e)=>t*e));for(let e=0;e<o;e++)r[e]=ct(t+e*i,s,n)}return r}function lt(t,e){if(0===t.length)return e[0];const n=t.reduce(((t,e)=>t*e));if(0===n)return[];if(n!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}.`);return ct(0,t,e)}function ht(t,e){const n=dt(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function dt(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function pt(t){t.forEach((e=>{C(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function ft(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let e=0;e<t.length-1;++e)r+=n[e]*t[e];return r}function gt(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let e=0;e<r.length-1;++e)r[e]=Math.floor(t/n[e]),t-=r[e]*n[e];return r[r.length-1]=t,r}function mt(t){return t&&t.then&&"function"==typeof t.then}const yt="tfjsflags";class bt{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(mt(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}(this.global.location.search);if(yt in t){t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}}function wt(){return xt}let kt,xt=null;function vt(){if(null==kt){let e;if("undefined"!=typeof window)e=window;else if(void 0!==t)e=t;else if(void 0!==N)e=N;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}kt=e}return kt}function St(t,e){const n=function(){const t=vt();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const It="Abs",Et="Acos",Dt="Acosh",$t="Add",Nt="AddN",Tt="All",Ft="Any",At="ArgMax",_t="ArgMin",Mt="Asin",Bt="Asinh",Ct="Atan",Rt="Atanh",Pt="Atan2",Kt="AvgPool",zt="AvgPoolGrad",Lt="AvgPool3D",qt="AvgPool3DGrad",Ot="BatchMatMul",Gt="BatchToSpaceND",Ut="Bincount",Wt="Cast",Ht="Ceil",jt="ClipByValue",Vt="Complex",Jt="ComplexAbs",Xt="Concat",Yt="Conv2D",Zt="Conv2DBackpropFilter",Qt="Conv2DBackpropInput",te="Conv3D",ee="Conv3DBackpropFilterV2",ne="Conv3DBackpropInputV2",re="Cos",oe="Cosh",se="Cumsum",ie="CropAndResize",ae="DenseBincount",ue="DepthToSpace",ce="DepthwiseConv2dNative",le="DepthwiseConv2dNativeBackpropFilter",he="DepthwiseConv2dNativeBackpropInput",de="Diag",pe="Dilation2D",fe="RealDiv",ge="Elu",me="EluGrad",ye="Erf",be="Equal",we="Exp",ke="ExpandDims",xe="Expm1",ve="FFT",Se="Fill",Ie="FlipLeftRight",Ee="Floor",De="FloorDiv",$e="FusedBatchNorm",Ne="GatherV2",Te="GatherNd",Fe="Greater",Ae="GreaterEqual",_e="Identity",Me="IFFT",Be="Imag",Ce="IsFinite",Re="IsInf",Pe="IsNan",Ke="LeakyRelu",ze="Less",Le="LessEqual",qe="LinSpace",Oe="Log",Ge="Log1p",Ue="LogicalAnd",We="LogicalNot",He="LogicalOr",je="LRN",Ve="LRNGrad",Je="Max",Xe="Maximum",Ye="MaxPool",Ze="MaxPoolGrad",Qe="MaxPool3D",tn="MaxPool3DGrad",en="MaxPoolWithArgmax",nn="Mean",rn="Min",on="Minimum",sn="MirrorPad",an="Mod",un="Multinomial",cn="Multiply",ln="Neg",hn="NotEqual",dn="NonMaxSuppressionV3",pn="NonMaxSuppressionV4",fn="NonMaxSuppressionV5",gn="OnesLike",mn="OneHot",yn="Pack",bn="PadV2",wn="Pow",kn="Prelu",xn="Prod",vn="Range",Sn="Real",In="Reciprocal",En="Relu",Dn="Reshape",$n="ResizeNearestNeighbor",Nn="ResizeNearestNeighborGrad",Tn="ResizeBilinear",Fn="ResizeBilinearGrad",An="Relu6",_n="Reverse",Mn="Round",Bn="Rsqrt",Cn="ScatterNd",Rn="Select",Pn="Selu",Kn="Slice",zn="Sin",Ln="Sinh",qn="Sign",On="Sigmoid",Gn="Softplus",Un="Sqrt",Wn="Sum",Hn="SpaceToBatchND",jn="SplitV",Vn="Softmax",Jn="SquaredDifference",Xn="Square",Yn="Sub",Zn="SparseToDense",Qn="StridedSlice",tr="Tan",er="Tanh",nr="Tile",rr="TopK",or="Transpose",sr="Unique",ir="Unpack",ar="UnsortedSegmentSum",ur="ZerosLike",cr="Step",lr="FromPixels",hr="RotateWithOffset",dr="_FusedMatMul",pr="FusedConv2D",fr="FusedDepthwiseConv2D",gr=St("kernelRegistry",(()=>new Map)),mr=St("gradRegistry",(()=>new Map));function yr(t,e){const n=vr(t,e);return gr.get(n)}function br(t){return mr.get(t)}function wr(t){const e=gr.entries(),n=[];for(;;){const{done:r,value:o}=e.next();if(r)break;const[s,i]=o,[a]=s.split("_");a===t&&n.push(i)}return n}function kr(t){const{kernelName:e,backendName:n}=t,r=vr(e,n);gr.has(r)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),gr.set(r,t)}function xr(t){const{kernelName:e}=t;mr.has(e)&&wt().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),mr.set(e,t)}function vr(t,e){return`${e}_${t}`}function Sr(t,e){return"string"===e?Dr(t):Ir([t],e)}function Ir(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=K(t)),wt().getBool("DEBUG")&&X(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function Er(){return wt().platform.now()}function Dr(t,e="utf-8"){return e=e||"utf-8",wt().platform.encode(t,e)}function $r(t,e="utf-8"){return e=e||"utf-8",wt().platform.decode(t,e)}class Nr{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Fr)}profileKernel(t,e,n){let r;const o=this.backendTimer.time((()=>{r=n()}));if(wt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{Tr(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then((t=>t.kernelMs)),extraInfo:o.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:o,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],o,n[2])}))}))}}function Tr(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Fr{logKernelProfile(t,e,n,r,o,s){const i="number"==typeof r?G(`${r}ms`,9):r.error,a=G(t,25),u=e.rank,c=e.size,l=G(e.shape.toString(),14);let h="";for(const t in o){const n=o[t];if(null!=n){const r=n.shape||e.shape,o=r.length;h+=`${t}: ${o}D ${o>0?r:""} `}}console.log(`%c${a}\t%c${i}\t%c${u}D ${l}\t%c${c}\t%c${h}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Ar(t,e,n,r){const o=ut(e),s=function(t,e,n,r){const o=z(e),s=r[r.length-1],i=new Array(s).fill(0),a=e.length,u="complex64"===n?Cr(t):t;if(a>1)for(let t=0;t<o/s;t++){const e=t*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],_r(u[e+t],0,n).length)}return i}(t,e,n,o),i=e.length,a=Br(t,e,n,o,s),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map((t=>"    "+t)).join("\n")),u.join("\n")}function _r(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:nt(t)?`'${t}'`:"bool"===n?Mr(t):parseFloat(t.toFixed(7)).toString(),G(r,e)}function Mr(t){return 0===t?"false":"true"}function Br(t,e,n,r,o,s=!0){const i="complex64"===n?2:1,a=e[0],u=e.length;if(0===u){if("complex64"===n){return[_r(Cr(t)[0],0,n)]}return"bool"===n?[Mr(t[0])]:[t[0].toString()]}if(1===u){if(a>20){const e=3*i;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((a-3)*i,a*i));return"complex64"===n&&(r=Cr(r),s=Cr(s)),["["+r.map(((t,e)=>_r(t,o[e],n))).join(", ")+", ..., "+s.map(((t,e)=>_r(t,o[a-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?Cr(t):Array.from(t)).map(((t,e)=>_r(t,o[e],n))).join(", ")+"]"]}const c=e.slice(1),l=r.slice(1),h=r[0]*i,d=[];if(a>20){for(let e=0;e<3;e++){const r=e*h,s=r+h;d.push(...Br(t.slice(r,s),c,n,l,o,!1))}d.push("...");for(let e=a-3;e<a;e++){const r=e*h,s=r+h;d.push(...Br(t.slice(r,s),c,n,l,o,e===a-1))}}else for(let e=0;e<a;e++){const r=e*h,s=r+h;d.push(...Br(t.slice(r,s),c,n,l,o,e===a-1))}const p=2===u?",":"";d[0]="["+d[0]+p;for(let t=1;t<d.length-1;t++)d[t]=" "+d[t]+p;let f=",\n";for(let t=2;t<u;t++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function Cr(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Rr{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=z(t),null!=n){const t=n.length;C(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||J(e,this.size),this.strides=ut(t)}set(t,...e){0===e.length&&(e=[0]),C(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Pr().makeTensor(this.values,this.shape,this.dtype)}}let Pr=null,Kr=null;class zr{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=z(t),this.strides=ut(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Kr.buffer(this.shape,this.dtype,t)}bufferSync(){return Kr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return lt(this.shape,t)}arraySync(){return lt(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const t=Pr().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>$r(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=Pr().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>$r(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Pr().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Pr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Kr.print(this,t)}clone(){return this.throwIfDisposed(),Kr.clone(this)}toString(t=!1){return Ar(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Kr.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Pr().makeVariable(this,t,e,n)}}Object.defineProperty(zr,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed});class Lr extends zr{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!L(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Pr().disposeTensor(this),this.dataId=t.dataId,Pr().incRef(this,null)}dispose(){Pr().disposeVariable(this),this.isDisposedInternal=!0}}var qr,Or,Gr,Ur,Wr;Object.defineProperty(Lr,Symbol.hasInstance,{value:t=>t instanceof zr&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(qr||(qr={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Or||(Or={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Gr||(Gr={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Ur||(Ur={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Wr||(Wr={}));const Hr={float32:Ur,int32:Or,bool:Gr,complex64:Wr};function jr(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Hr[t][e]}function Vr(t){return jr(t,"int32")}function Jr(t,e){if(t.dtype===e.dtype)return[t,e];const n=jr(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Xr(t,e){C(t.dtype===e.dtype,(()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`))}function Yr(t){const e=[];return Zr(t,e,new Set),e}function Zr(t,e,n){if(null==t)return;if(t instanceof zr)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const o=t;for(const t in o){const r=o[t];n.has(r)||(n.add(r),Zr(r,e,n))}}class Qr{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class to{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Qr}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Nr(this.backendInstance),!0}setupRegisteredKernels(){wr(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){wr(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof F||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId)&&(this.registry[t]=n,this.pendingBackendInit=null,!0))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return console.warn(`Initialization of backend ${t} failed`),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:o}=this.initializeBackend(n);if(o||r)return{name:n,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,o=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,o,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return to.nextTensorId++}nextVariableId(){return to.nextVariableId++}clone(t){const e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e="float32",n={x:t},r={dtype:e};return no.runKernelFunc((n=>n.cast(t,e)),n,null,Wt,r)}})),[],{}),e}runKernel(t,e,n,r,o){return this.runKernelFunc(null,e,null,t,n,r,o)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let o=0;n.forEach((t=>{o+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-e-o-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t,e,n,r,o,s,i){let a,u=[];const c=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const l=this.state.numBytes,h=this.state.numTensors;let d;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const p=yr(r,this.backendName);let f,g;if(null!=p)d=()=>{const t=this.backend.numDataIds();f=p.kernelFunc({inputs:e,attrs:o,backend:this.backend});const n=Array.isArray(f)?f:[f];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,t,n);const a=n.map((t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:r}=t;return this.makeTensorFromDataId(e,n,r)}));if(c){let t=this.getTensorsForGradient(r,e,a);if(null==t){null==i&&(i=[]);const e=a.filter(((t,e)=>i[e]));t=(s||[]).slice().concat(e)}u=this.saveTensorsForBackwardMode(t)}return a};else{if(null==t)throw new Error(`Error running ${r}: Neither modular kernel nor forward func passed`);const e=t=>{c&&(u=t.map((t=>this.keep(this.clone(t)))))};d=()=>{const n=this.backend.numDataIds();f=this.tidy((()=>t(this.backend,e)));const o=Array.isArray(f)?f:[f];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,o),o}}return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(g=this.profiler.profileKernel(r,e,(()=>d())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),a=g.outputs):a=d()})),c&&this.addTapeNode(r,e,a,n,u,o),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-l,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-h,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map((t=>null!=e[t]?e[t].shape:null)),outputShapes:a.map((t=>t.shape)),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(f)?a:a[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=br(t);if(null!=r){const t=r.inputsToSave||[],o=r.outputsToSave||[];let s;r.saveAllInputs?(C(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const i=n.filter(((t,e)=>o[e]));return s.concat(i)}return null}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let o=t;"string"===n&&nt(t[0])&&(o=t.map((t=>Dr(t))));const s=r.write(o,e,n),i=new zr(e,n,s,this.nextTensorId());if(this.incRef(i,r),"string"===n){const t=this.state.tensorInfo.get(s),e=et(o);this.state.numBytes+=e-t.bytes,t.bytes=e}return i}makeTensorFromDataId(t,e,n,r){const o=new zr(e,n=n||"float32",t,this.nextTensorId());return this.incRef(o,r),o}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const o=new Lr(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}incRef(t,e){const n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*tt(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof Lr||this.track(t)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;const e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):(e.backend.decComplexRef(t.dataId),this.state.tensorInfo.get(t.dataId).refCount--)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,o,s){const i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:o},a=br(t);null!=a&&(r=a.gradFunc),null!=r&&(i.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=dt(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],o,s))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Yr(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(C(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));C(o instanceof zr,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},o={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const s=t[n],i=s.inputs;for(const t in i){const n=i[t];let a=!1;for(let t=0;t<e.length;t++)if(r[n.id]){s.outputs.forEach((t=>r[t.id]=!0)),a=!0,o[s.id]=!0;break}if(a)break}}const s={};s[n.id]=!0;const i={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(s[n.outputs[t].id]){for(const t in r)s[r[t].id]=!0,i[n.id]=!0;break}}const a=[];for(let e=0;e<t.length;e++){const n=t[e];if(o[n.id]&&i[n.id]){const t={};for(const e in n.inputs){const o=n.inputs[e];r[o.id]&&(t[e]=o)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,a.push(e)}}return a}(this.state.activeTape,e,o);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[o.id]=null==n?function(t){const e=ht(z(t),"float32");return no.makeTensor(e,t,"float32")}(o.shape):n,function(t,e,n,r){for(let o=e.length-1;o>=0;o--){const s=e[o],i=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(i);for(const e in s.inputs){if(!(e in a))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(a)}.`);const o=n((()=>a[e]()));if("float32"!==o.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${o.dtype}'`);const i=s.inputs[e];if(!L(o.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${o.shape}', which does not match the shape of the input '${i.shape}'`);if(null==t[i.id])t[i.id]=o;else{const e=t[i.id];t[i.id]=r(e,o),e.dispose()}}}}(t,s,(t=>this.tidy(t)),ro);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:o,grads:r}}))}customGrad(t){return C(it(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;C(e.every((t=>t instanceof zr)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return e.forEach(((t,e)=>{r[e]=t})),this.runKernelFunc(((r,o)=>(n=t(...e,o),C(n.value instanceof zr,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),C(it(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value)),r,((t,r)=>{const o=n.gradFunc(t,r),s=Array.isArray(o)?o:[o];C(s.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),C(s.every((t=>t instanceof zr)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return s.forEach(((t,e)=>{i[e]=()=>t})),i}))}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=Er(),n=await this.backend.time(t);return n.wallMs=Er()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Qr;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function eo(){const t=vt();if(null==t._tfengine){const e=new bt(t);t._tfengine=new to(e)}var e;return e=t._tfengine.ENV,xt=e,Pr=()=>t._tfengine,t._tfengine}to.nextTensorId=0,to.nextVariableId=0;const no=eo();function ro(t,e){const n={a:t,b:e};return no.runKernel($t,n)}function oo(){if("undefined"!=typeof navigator&&null!=navigator){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function so(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const io=wt();function ao(t,e){let n=t;if(Q(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||Q(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&wt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&uo(t,r,[]),r}function uo(t,e,n){if(n=n||[],!Array.isArray(t)&&!Q(t))return void C(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));C(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),C(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let e=0;e<t.length;++e)uo(t[e],r,n.concat(e))}function co(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function lo(t,e,n,r="numeric"){if(t instanceof zr)return co(r,t.dtype,e,n),t;let o=st(t);if("string"!==o&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),co(r,o,e,n),null==t||!Q(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=ao(t,o);Q(t)||Array.isArray(t)||(t=[t]);const i="string"!==o?Ir(t,o):K(t,[],!0);return no.makeTensor(i,s,o)}function ho(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,o)=>lo(t,`${e}[${o}]`,n,r)))}io.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),io.registerFlag("IS_BROWSER",(()=>so())),io.registerFlag("IS_NODE",(()=>void 0!==N&&void 0!==N.versions&&void 0!==N.versions.node)),io.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),io.registerFlag("PROD",(()=>!1)),io.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>io.getBool("DEBUG"))),io.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),io.registerFlag("IS_TEST",(()=>!1)),io.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0));function po(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const o=(...t)=>{no.startScope(n);try{const e=r(...t);return mt(e)&&console.error("Cannot return a Promise inside of tidy."),no.endScope(e),e}catch(t){throw no.endScope(null),t}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}const fo=po({complex_:function(t,e){const n=lo(t,"real","complex"),r=lo(e,"imag","complex");R(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const o={real:n,imag:r};return no.runKernel(Vt,o)}});function go(t,e,n,r){if(null==r&&(r=st(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Q(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){pt(e);const t=z(e),r=z(n);C(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],o=t!==n.length-1||r!==z(e.slice(t));C(n[t]===e[t]||!o,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return Q(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?Ir(t,r):K(t,[],!0),no.makeTensor(t,e,r)}function mo(t,e,n){return go(t,e,ao(t,n),n)}const yo={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function bo(t,e){const n=[],r=[],o=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<o.length;++s){const i=o[s],a=Array.isArray(t)?t[s].tensor:t[i];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${a.dtype}`);const u={name:i,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise((async t=>{const e=await a.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+4*e.length,r=new Uint8Array(n);let o=0;for(let t=0;t<e.length;t++){const n=e[t],s=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(s,o),o+=4,r.set(n,o),o+=n.length}t(r)}));r.push(t)}else r.push(a.data());null!=e&&(u.group=e),n.push(u)}return{data:ko(await Promise.all(r)),specs:n}}function wo(t,e){const n={};let r,o=0;for(const s of e){const e=s.name,i=s.dtype,a=s.shape,u=z(a);let c;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==i)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${i}.`)}const a=yo[n.dtype],l=t.slice(o,o+u*a),h="uint8"===n.dtype?new Uint8Array(l):new Uint16Array(l);if("float32"===i)if("uint8"===n.dtype||"uint16"===n.dtype){c=new Float32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=Do()),c=r(h)}else{if("int32"!==i)throw new Error(`Unsupported dtype in weight '${e}': ${i}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);c=new Int32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];c[t]=Math.round(e*n.scale+n.min)}}o+=u*a}else if("string"===i){const e=z(s.shape);c=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(o,o+4))[0];o+=4;const n=new Uint8Array(t.slice(o,o+e));c.push(n),o+=e}}else{const r=yo[i],s=t.slice(o,o+u*r);if("float32"===i)c=new Float32Array(s);else if("int32"===i)c=new Int32Array(s);else if("bool"===i)c=new Uint8Array(s);else{if("complex64"!==i)throw new Error(`Unsupported dtype in weight '${e}': ${i}`);{c=new Float32Array(s);const t=new Float32Array(c.length/2),r=new Float32Array(c.length/2);for(let e=0;e<t.length;e++)t[e]=c[2*e],r[e]=c[2*e+1];const o=mo(t,a,"float32"),i=mo(r,a,"float32");n[e]=fo(o,i),o.dispose(),i.dispose()}}o+=u*r}"complex64"!==i&&(n[e]=mo(c,a,i))}return n}function ko(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}));const r=new Uint8Array(e);let o=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),o),o+=t.byteLength})),r.buffer}const xo=void 0!==r&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function vo(t){return xo?r.byteLength(t):new Blob([t]).size}function So(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function Io(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function Eo(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:vo(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:vo(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function Do(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let o=0;o<r.length;o++){const i=r[o],a=t[n[i>>10]+(1023&i)]+e[i>>10];s[o]=a}return new Float32Array(o)}}class $o{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==$o.instance&&($o.instance=new $o),$o.instance}static registerSaveRouter(t){$o.getInstance().saveRouters.push(t)}static registerLoadRouter(t){$o.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return $o.getHandlers(t,"save")}static getLoadHandlers(t,e){return $o.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?$o.getInstance().loadRouters:$o.getInstance().saveRouters).forEach((e=>{const o=e(t,n);null!==o&&r.push(o)})),r}}const No=t=>$o.registerSaveRouter(t),To=t=>$o.registerLoadRouter(t),Fo=t=>$o.getSaveHandlers(t),Ao=(t,e)=>$o.getLoadHandlers(t,e),_o="tensorflowjs",Mo="models_store",Bo="model_info_store";function Co(){if(!wt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ro(t){const e=t.result;e.createObjectStore(Mo,{keyPath:"modelPath"}),e.createObjectStore(Bo,{keyPath:"modelPath"})}class Po{constructor(t){if(this.indexedDB=Co(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(_o,1);r.onupgradeneeded=()=>Ro(r),r.onsuccess=()=>{const o=r.result;if(null==e){const e=o.transaction(Mo,"readonly"),r=e.objectStore(Mo).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return o.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(o.close(),n(r.error)),e.oncomplete=()=>o.close()}else{const r=Eo(e),s=o.transaction(Bo,"readwrite");let i=s.objectStore(Bo);const a=i.put({modelPath:this.modelPath,modelArtifactsInfo:r});let u;a.onsuccess=()=>{u=o.transaction(Mo,"readwrite");const a=u.objectStore(Mo).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});a.onsuccess=()=>t({modelArtifactsInfo:r}),a.onerror=t=>{i=s.objectStore(Bo);const e=i.delete(this.modelPath);e.onsuccess=()=>(o.close(),n(a.error)),e.onerror=t=>(o.close(),n(a.error))}},a.onerror=t=>(o.close(),n(a.error)),s.oncomplete=()=>{null==u?o.close():u.oncomplete=()=>o.close()}}},r.onerror=t=>n(r.error)}))}}Po.URL_SCHEME="indexeddb://";const Ko=t=>{return wt().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Po.URL_SCHEME)?(e=t.slice(Po.URL_SCHEME.length),new Po(e)):null;var e};$o.registerSaveRouter(Ko),$o.registerLoadRouter(Ko);class zo{constructor(){this.indexedDB=Co()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(_o,1);n.onupgradeneeded=()=>Ro(n),n.onsuccess=()=>{const r=n.result,o=r.transaction(Bo,"readonly"),s=o.objectStore(Bo).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),o.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(Po.URL_SCHEME)?e.slice(Po.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(_o,1);r.onupgradeneeded=()=>Ro(r),r.onsuccess=()=>{const o=r.result,s=o.transaction(Bo,"readwrite"),i=s.objectStore(Bo),a=i.get(t);let u;a.onsuccess=()=>{if(null==a.result)return o.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=i.delete(t),s=()=>{u=o.transaction(Mo,"readwrite");const r=u.objectStore(Mo).delete(t);r.onsuccess=()=>e(a.result.modelArtifactsInfo),r.onerror=t=>n(a.error)};r.onsuccess=s,r.onerror=t=>(s(),o.close(),n(a.error))}},a.onerror=t=>(o.close(),n(a.error)),s.oncomplete=()=>{null==u?o.close():u.oncomplete=()=>o.close()}},r.onerror=t=>n(r.error)}))}}const Lo="/",qo="tensorflowjs_models",Oo="info",Go="model_topology",Uo="weight_specs",Wo="weight_data",Ho="model_metadata";function jo(t){return{info:[qo,t,Oo].join(Lo),topology:[qo,t,Go].join(Lo),weightSpecs:[qo,t,Uo].join(Lo),weightData:[qo,t,Wo].join(Lo),modelMetadata:[qo,t,Ho].join(Lo)}}function Vo(t){const e=t.split(Lo);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Lo)}class Jo{constructor(t){if(!wt().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=jo(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=Eo(t);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(xo)return r.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,r=e.length;t<r;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(t.weightData));const s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};return null!=t.signature&&(s.signature=t.signature),null!=t.userDefinedMetadata&&(s.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(s.modelInitializer=t.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=o;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const t=JSON.parse(s);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer)}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(xo){const e=r.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(i),e}}Jo.URL_SCHEME="localstorage://";const Xo=t=>{return wt().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Jo.URL_SCHEME)?(e=t.slice(Jo.URL_SCHEME.length),new Jo(e)):null;var e};$o.registerSaveRouter(Xo),$o.registerLoadRouter(Xo);class Yo{constructor(){C(wt().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),C("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=qo+Lo,n=Lo+Oo;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(e)&&o.endsWith(n)){t[Vo(o)]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){var e;const n=jo(t=(e=t).startsWith(Jo.URL_SCHEME)?e.slice(Jo.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),r}}const Zo="://";class Qo{constructor(){this.managers={}}static getInstance(){return null==Qo.instance&&(Qo.instance=new Qo),Qo.instance}static registerManager(t,e){C(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(Zo)&&(t=t.slice(0,t.indexOf(Zo))),C(t.length>0,(()=>"scheme must not be an empty string."));const n=Qo.getInstance();C(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function ts(t){if(-1===t.indexOf(Zo))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Qo.getSchemes().join(",")}`);return{scheme:t.split(Zo)[0],path:t.split(Zo)[1]}}async function es(t,e,n=!1){C(t!==e,(()=>`Old path and new path are the same: '${t}'`));const r=$o.getLoadHandlers(t);C(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${t}.`)),C(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`));const o=r[0],s=$o.getSaveHandlers(e);C(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${e}.`)),C(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`));const i=s[0],a=ts(t).scheme,u=ts(t).path,c=a===ts(t).scheme,l=await o.load();n&&c&&await Qo.getManager(a).removeModel(u);const h=await i.save(l);return n&&!c&&await Qo.getManager(a).removeModel(u),h.modelArtifactsInfo}async function ns(){const t=Qo.getSchemes(),e={};for(const n of t){const t=await Qo.getManager(n).listModels();for(const r in t){e[n+Zo+r]=t[r]}}return e}async function rs(t){const e=ts(t);return Qo.getManager(e.scheme).removeModel(e.path)}async function os(t,e){return es(t,e,!1)}async function ss(t,e){return es(t,e,!0)}class is{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(wt().get("IS_BROWSER")){wt().setPlatform("browser",new is);try{Qo.registerManager(Jo.URL_SCHEME,new Yo)}catch(t){}try{Qo.registerManager(Po.URL_SCHEME,new zo)}catch(t){}}const as=()=>n(158);let us;class cs{constructor(){this.util=n(159),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=wt().global.fetch?wt().global.fetch(t,e):(null==us&&(us=as()),us(t,e))}now(){const t=N.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}}function ls(t,e="float32",n){return e=e||"float32",pt(t),new Rr(t,e,n)}wt().get("IS_NODE")&&wt().setPlatform("node",new cs);const hs=po({cast_:function(t,e){const n=lo(t,"x","cast");if(!Y(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},o={dtype:e};return no.runKernel(Wt,r,o)}});const ds=po({clone_:function(t){const e={x:lo(t,"x","clone","string_or_numeric")};return no.runKernel(_e,e)}});eo();Kr={buffer:ls,cast:hs,clone:ds,print:function(t,e=!1){console.log(t.toString(e))}};const ps=po({matMul_:function(t,e,n=!1,r=!1){let o=lo(t,"a","matMul"),s=lo(e,"b","matMul");[o,s]=Jr(o,s);const i={a:o,b:s},a={transposeA:n,transposeB:r};return no.runKernel(Ot,i,a)}});const fs=po({oneHot_:function(t,e,n=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:lo(t,"indices","oneHot","int32")},s={depth:e,onValue:n,offValue:r};return no.runKernel(mn,o,s)}});const gs=po({transpose_:function(t,e){const n=lo(t,"x","transpose");if(null==e&&(e=n.shape.map(((t,e)=>e)).reverse()),C(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`)),e.forEach((t=>{C(t>=0&&t<n.rank,(()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`))})),n.rank<=1)return n.clone();const r={x:n},o={perm:e};return no.runKernel(or,r,o)}});function ms(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${o}.`;if(n.rank<o)throw new Error(s+` update.rank < ${o}. `);if(t.length<r+(n.rank-o))throw new Error(s+` Output shape length < ${r+(n.rank-o)}`);if(n.rank!==o+t.length-r)throw new Error(s+" update.rank != "+(o+t.length-r));for(let t=0;t<o;++t)if(n.shape[t]!==e.shape[t])throw new Error(s+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-o;++e)if(n.shape[e+o]!==t[e+r])throw new Error(s+` updates.shape[${e+o}] (${n.shape[e+o]}) != shape[${e+o}] (${t[e+o]})`)}function ys(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}ms(n,e,t)}function bs(t,e,n){const r=e.shape.length,o=r>1?e.shape[r-1]:1,s=n.length;let i=1;for(let t=o;t<s;++t)i*=n[t];const a=o<1?1:o;return{sliceRank:o,numUpdates:z(e.shape)/a,sliceSize:i,strides:[...ut(n.slice(0,o)),1],outputSize:z(n)}}function ws(t,e,n){const r=t.shape.length;C(r===e.length,(()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`)),C(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let o=0;o<r;++o)C(e[o]+n[o]<=t.shape[o],(()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${e[o]+n[o]}) would overflow input.shape[${o}] (${t.shape[o]})`))}function ks(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function xs(t,e,n){const r=[];for(let o=0;o<t.length;o++)r[o]=Math.ceil((e[o]-t[o])/n[o]);return r}function vs(t,e,n,r){const o=[...t];for(let t=o.length;t<r.length;t++)o.push(1);for(let t=0;t<n;t++)0===t?o[e]=1:(o.splice(e,0,1),o.pop());return o}function Ss(t,e,n){return n<=t?n:n-(e-1)}function Is(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function Es(t,e,n,r,o,s,i,a,u){const c=t.length;let l=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&n>0){const u=e[0],c=n+1;l=Ds(i,u,c,r,t),h=$s(a,u,c,o,t),d=vs(s,u,c,t)}else for(let e=0;e<c;e++)l[e]=Ts(i,r,s,t,e,u),h[e]=Fs(a,o,s,t,e,u),d[e]=Ns(s,e,u);return{begin:l,end:h,strides:d}}function Ds(t,e,n,r,o){const s=[...o],i=Is(n,e);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{const i=Ss(e,n,o);let a=r[i];t&1<<i&&(a=0),s[o]=a}return s}function $s(t,e,n,r,o){const s=[...o],i=Is(n,e);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const i=Ss(e,n,o);let a=r[i];t&1<<i&&(a=Number.MAX_SAFE_INTEGER),s[o]=a}for(let t=0;t<s.length;t++){const e=o[t];s[t]<0&&(s[t]+=e),s[t]=_(0,s[t],o[t])}return s}function Ns(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function Ts(t,e,n,r,o,s){let i=e[o];const a=n[o]||1;(t&1<<o||s&1<<o||null==i)&&(i=a>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[o];return i<0&&(i+=u),i=_(0,i,u-1),i}function Fs(t,e,n,r,o,s){let i=e[o];const a=n[o]||1;(t&1<<o||s&1<<o||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[o];return i<0&&(i+=u),i=a>0?_(0,i,u):_(-1,i,u-1),i}function As(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function _s(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Ms(t,e,n){let r;const o=t.shape.length;let s;return r="number"==typeof e?[e,...new Array(o-1).fill(0)]:e.length<o?e.concat(new Array(o-e.length).fill(0)):e.slice(),r.forEach((t=>{C(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(o).fill(-1):"number"==typeof n?[n,...new Array(o-1).fill(-1)]:n.length<o?n.concat(new Array(o-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(C(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-r[n]))),[r,s]}function Bs(t,e,n,r,o,s,i,a,u){let c=e.slice(),l=n.slice(),h=r;null==r&&(h=new Array(c.length));const d=ks(i);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==u)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=t.length-c.length,f=ks(a),g=t.slice();f.forEach((t=>{c[t]=0,l[t]=1,g.splice(t,0,1)}));const{begin:m,end:y,strides:b}=Es(g,d,p,c,l,h,o,s,i);c=m,l=y,h=b;const w=ks(u);w.forEach((t=>{l[t]=c[t]+1,h[t]=1}));const k=xs(c,l,h),x=k.filter(((t,e)=>-1===w.indexOf(e)));return{nonStrided:h.every((t=>1===t)),$begin:c,$end:l,$strides:h,size:k,newShape:g,outShape:x}}var Cs=Object.freeze({__proto__:null,assertParamsValid:ws,maskToAxes:ks,computeOutShape:xs,stridesWithElidedDims:vs,getNormalizedAxes:Es,startIndicesWithElidedDims:Ds,stopIndicesWithElidedDims:$s,stridesForAxis:Ns,startForAxis:Ts,stopForAxis:Fs,isSliceContinous:As,computeFlatOffset:_s,parseSliceParams:Ms,sliceInfo:Bs});function Rs(t){wt().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Ps(){return no}function Ks(t,e){return no.tidy(t,e)}function zs(t){Yr(t).forEach((t=>t.dispose()))}function Ls(t){return no.keep(t)}function qs(t){return no.setBackend(t)}function Os(){return no.backendName}function Gs(t,e,n=1){return no.registerBackend(t,e,n)}const Us=po({add_:function(t,e){let n=lo(t,"a","add"),r=lo(e,"b","add");[n,r]=Jr(n,r);const o={a:n,b:r};return no.runKernel($t,o)}});const Ws=po({floorDiv_:function(t,e){let n=lo(t,"a","floorDiv"),r=lo(e,"b","floorDiv");[n,r]=Jr(n,r);const o={a:n,b:r};return no.runKernel(De,o)}});const Hs=po({div_:function(t,e){let n=lo(t,"a","div"),r=lo(e,"b","div");if([n,r]=Jr(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Ws(n,r);const o={a:n,b:r};return no.runKernel(fe,o,{})}});const js=po({mul_:function(t,e){let n=lo(t,"a","mul"),r=lo(e,"b","mul");[n,r]=Jr(n,r);const o={a:n,b:r};return no.runKernel(cn,o)}});const Vs=po({abs_:function(t){const e=lo(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return no.runKernel(Jt,t)}{const t={x:e};return no.runKernel(It,t)}}});const Js=po({acos_:function(t){const e={x:lo(t,"x","acos")};return no.runKernel(Et,e)}});const Xs=po({acosh_:function(t){const e={x:lo(t,"x","acosh")};return no.runKernel(Dt,e)}});const Ys=po({all_:function(t,e=null,n=!1){const r={x:lo(t,"x","all","bool")},o={axis:e,keepDims:n};return no.runKernel(Tt,r,o)}});const Zs=po({any_:function(t,e=null,n=!1){const r={x:lo(t,"x","any","bool")},o={axis:e,keepDims:n};return no.runKernel(Ft,r,o)}});const Qs=po({argMax_:function(t,e=0){const n={x:lo(t,"x","argMax")},r={axis:e};return no.runKernel(At,n,r)}});const ti=po({argMin_:function(t,e=0){const n={x:lo(t,"x","argMin")},r={axis:e};return no.runKernel(_t,n,r)}});const ei=po({asin_:function(t){const e={x:lo(t,"x","asin")};return no.runKernel(Mt,e)}});const ni=po({asinh_:function(t){const e={x:lo(t,"x","asinh")};return no.runKernel(Bt,e)}});const ri=po({atan_:function(t){const e={x:lo(t,"x","atan")};return no.runKernel(Ct,e)}});const oi=po({atan2_:function(t,e){let n=lo(t,"a","atan2"),r=lo(e,"b","atan2");[n,r]=Jr(n,r);const o={a:n,b:r};return no.runKernel(Pt,o)}});const si=po({atanh_:function(t){const e={x:lo(t,"x","atanh")};return no.runKernel(Rt,e)}});function ii(t,e,n,r,o="NHWC",s){return ci(t,[...e,t[3]],n,s,r,null,null,bi(o))}function ai(t,e,n,r,o,s,i="channelsLast"){const[a,u]=di(e);let c;if("channelsLast"===i)c=[a,u,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);c=[a,u,t[1],t[1]]}return ci(t,c,n,r,o,s,!1,i)}function ui(t,e,n,r,o,s,i="NDHWC"){const[a,u,c]=pi(e);let l,h;if("NDHWC"===i)h="channelsLast",l=[a,u,c,t[4],t[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",l=[a,u,c,t[1],t[1]]}return li(t,l,n,r,o,!1,h,s)}function ci(t,e,n,r,o,s,i=!1,a="channelsLast"){let[u,c,l,h]=[-1,-1,-1,-1];if("channelsLast"===a)[u,c,l,h]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[u,h,c,l]=t}const[d,p,,f]=e,[g,m]=di(n),[y,b]=di(r),w=fi(d,y),k=fi(p,b),{padInfo:x,outHeight:v,outWidth:S}=function(t,e,n,r,o,s,i,a,u){let c,l,h;if("number"==typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const o=function(t,e,n,r,o){null==r&&(r=hi(t,e,n));const s=t[0],i=t[1],a=gi((s-e+2*r)/n+1,o),u=gi((i-e+2*r)/n+1,o);return[a,u]}([e,n],s,r,t,a);l=o[0],h=o[1]}else if("same"===t){l=Math.ceil(e/r),h=Math.ceil(n/o);const t=Math.max(0,(l-1)*r+s-e),a=Math.max(0,(h-1)*o+i-n),u=Math.floor(t/2),d=t-u,p=Math.floor(a/2);c={top:u,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((e-s+1)/r),h=Math.ceil((n-i+1)/o);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===u?t[1][0]:t[2][0],p="channelsLast"===u?t[1][1]:t[2][1],f="channelsLast"===u?t[2][0]:t[3][0],g="channelsLast"===u?t[2][1]:t[3][1];c={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},l=gi((e-s+d+p)/r+1,a),h=gi((n-i+f+g)/o+1,a)}}return{padInfo:c,outHeight:l,outWidth:h}}(o,c,l,g,m,w,k,s,a),I=i?f*h:f;let E;return"channelsFirst"===a?E=[u,I,v,S]:"channelsLast"===a&&(E=[u,v,S,I]),{batchSize:u,dataFormat:a,inHeight:c,inWidth:l,inChannels:h,outHeight:v,outWidth:S,outChannels:I,padInfo:x,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:w,effectiveFilterWidth:k,dilationHeight:y,dilationWidth:b,inShape:t,outShape:E,filterShape:e}}function li(t,e,n,r,o,s=!1,i="channelsLast",a){let[u,c,l,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,c,l,h,d]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,c,l,h]=t}const[p,f,g,,m]=e,[y,b,w]=pi(n),[k,x,v]=pi(r),S=fi(p,k),I=fi(f,x),E=fi(g,v),{padInfo:D,outDepth:$,outHeight:N,outWidth:T}=function(t,e,n,r,o,s,i,a,u,c,l){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,o,s){null==o&&(o=hi(t,e,r));const i=t[0],a=t[1],u=t[2],c=gi((i-e+2*o)/r+1,s),l=gi((a-e+2*o)/r+1,s),h=gi((u-e+2*o)/r+1,s);return[c,l,h,n]}([e,n,r,1],a,1,o,t,l);d=s[0],p=s[1],f=s[2]}else if("same"===t){d=Math.ceil(e/o),p=Math.ceil(n/s),f=Math.ceil(r/i);const t=(d-1)*o+a-e,l=(p-1)*s+u-n,g=(f-1)*i+c-r,m=Math.floor(t/2),y=t-m,b=Math.floor(l/2),w=l-b,k=Math.floor(g/2);h={top:b,bottom:w,left:k,right:g-k,front:m,back:y,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/o),p=Math.ceil((n-u+1)/s),f=Math.ceil((r-c+1)/i)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(o,c,l,h,y,b,w,S,I,E,a),F=s?m*d:m;let A;return"channelsFirst"===i?A=[u,F,$,N,T]:"channelsLast"===i&&(A=[u,$,N,T,F]),{batchSize:u,dataFormat:i,inDepth:c,inHeight:l,inWidth:h,inChannels:d,outDepth:$,outHeight:N,outWidth:T,outChannels:F,padInfo:D,strideDepth:y,strideHeight:b,strideWidth:w,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:E,dilationDepth:k,dilationHeight:x,dilationWidth:v,inShape:t,outShape:A,filterShape:e}}function hi(t,e,n,r=1){const o=fi(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}function di(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function pi(t){return"number"==typeof t?[t,t,t]:t}function fi(t,e){return e<=1?t:t+(t-1)*(e-1)}function gi(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function mi(t){const[e,n,r]=di(t);return 1===e&&1===n&&1===r}function yi(t,e){return mi(t)||mi(e)}function bi(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}const wi=po({reshape_:function(t,e){const n={x:lo(t,"x","reshape","string_or_numeric")},r={shape:e};return no.runKernel(Dn,n,r)}});const ki=po({avgPool_:function(t,e,n,r,o){const s=lo(t,"x","avgPool","float32");C(yi(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=s,a=!1;3===s.rank&&(a=!0,i=wi(s,[1,s.shape[0],s.shape[1],s.shape[2]])),C(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),null!=o&&C(q(r),(()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const u={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:o};let l=no.runKernel(Kt,u,c);return l=hs(l,s.dtype),a?wi(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const xi=po({concat_:function(t,e=0){C(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=ho(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)})),1===n.length)return ds(n[0]);const r=n,o={axis:e};return no.runKernel(Xt,r,o)}});const vi=po({sigmoid_:function(t){const e={x:lo(t,"x","sigmoid")};return no.runKernel(On,e)}});const Si=po({slice_:function(t,e,n){const r=lo(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const o={x:r},s={begin:e,size:n};return no.runKernel(Kn,o,s)}});const Ii=po({tanh_:function(t){const e={x:lo(t,"x","tanh")};return no.runKernel(er,e)}});const Ei=po({batchToSpaceND_:function(t,e,n){const r=lo(t,"x","batchToSpaceND"),o=e.reduce(((t,e)=>t*e));C(r.rank>=1+e.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`)),C(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),C(r.shape[0]%o==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`));const s={x:r},i={blockShape:e,crops:n};return no.runKernel(Gt,s,i)}});const Di=po({batchNorm_:function(t,e,n,r,o,s){null==s&&(s=.001);const i=lo(t,"x","batchNorm"),a=lo(e,"mean","batchNorm"),u=lo(n,"variance","batchNorm");let c,l;null!=o&&(c=lo(o,"scale","batchNorm")),null!=r&&(l=lo(r,"offset","batchNorm")),C(a.rank===u.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),C(null==l||a.rank===l.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),C(null==c||a.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(t){let e;return e=0===t.rank||1===t.rank?wi(t,[1,1,1,t.size]):2===t.rank?wi(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?wi(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(i),scale:c,offset:l,mean:a,variance:u},d={varianceEpsilon:s},p=no.runKernel($e,h,d);return wi(p,i.shape)}});const $i=po({broadcastTo_:function(t,e){let n=lo(t,"broadcastTo","x");const r=n.shape;if(e.some((t=>!(t>0)||t%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=wi(n,t)}const o=n.shape,s=Array.from(e);for(let t=e.length-1;t>=0;t--)if(o[t]===e[t])s[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return ds(n);const i={x:n},a={reps:s};return no.runKernel(nr,i,a)}});const Ni=po({ceil_:function(t){const e={x:lo(t,"x","ceil")};return no.runKernel(Ht,e)}});const Ti=po({clipByValue_:function(t,e,n){const r=lo(t,"x","clipByValue");C(e<=n,(()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`));const o={x:r},s={clipValueMin:e,clipValueMax:n};return no.runKernel(jt,o,s)}});const Fi=po({conv2d_:function(t,e,n,r,o="NHWC",s=[1,1],i){const a=lo(t,"x","conv2d"),u=lo(e,"filter","conv2d");let c=a,l=!1;3===a.rank&&(l=!0,c=wi(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(4===c.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`)),C(4===u.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`)),null!=i&&C(q(r),(()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`));const h="NHWC"===o?c.shape[3]:c.shape[1];C(h===u.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`)),C(yi(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const d={x:c,filter:u},p={strides:n,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},f=no.runKernel(Yt,d,p);return l?wi(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Ai=po({conv1d_:function(t,e,n,r,o="NWC",s=1,i){const a=lo(t,"x","conv1d"),u=lo(e,"filter","conv1d");let c=a,l=!1;2===a.rank&&(l=!0,c=wi(a,[1,a.shape[0],a.shape[1]])),C(3===c.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`)),C(3===u.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`)),null!=i&&C(q(r),(()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`)),C(c.shape[2]===u.shape[1],(()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`)),C(yi(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),C("NWC"===o,(()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`));const h=wi(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=wi(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Fi(d,h,[1,n],r,"NHWC",[1,s],i);return wi(p,l?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const _i=po({conv2DBackpropInput_:function(t,e,n,r,o,s="NHWC",i){C(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let a=t,u=e,c=!1;3===e.rank&&(c=!0,u=wi(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),C(4===a.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`)),C(4===u.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`)),C(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const l="NHWC"===s?a[3]:a[1],h="NHWC"===s?u.shape[3]:u.shape[1];C(l===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[2]}.`)),C(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),null!=i&&C(q(o),(()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`));const d={dy:u,filter:n},p={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},f=no.runKernel(Qt,d,p);return c?wi(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Mi=po({conv2dTranspose_:function(t,e,n,r,o,s){const i=lo(t,"x","conv2dTranspose"),a=lo(e,"filter","conv2dTranspose");return _i(n,i,a,r,o,"NHWC",s)}});const Bi=po({conv3DBackpropInput_:function(t,e,n,r,o){C(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let s=t,i=e,a=!1;4===e.rank&&(a=!0,i=wi(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const u=s[4],c=i.shape[4];C(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),C(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),C(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),C(u===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`)),C(c===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`));const l={dy:i,filter:n},h={pad:o,strides:r,inputShape:s},d=no.runKernel(ne,l,h);return a?wi(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Ci=po({cos_:function(t){const e={x:lo(t,"x","cos")};return no.runKernel(re,e)}});const Ri=po({cosh_:function(t){const e={x:lo(t,"x","cosh")};return no.runKernel(oe,e)}});const Pi=po({cumsum_:function(t,e=0,n=!1,r=!1){const o={x:lo(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return no.runKernel(se,o,s)}});const Ki=po({depthToSpace_:function(t,e,n="NHWC"){const r=lo(t,"x","depthToSpace"),o="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];C(o*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${e}  for depthToSpace with input shape\n    ${r.shape}`)),C(s*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e} for depthToSpace with input shape\n        ${r.shape}`)),C(i%(e*e)==0,(()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`));const a={x:r},u={blockSize:e,dataFormat:n};return no.runKernel(ue,a,u)}});const zi=po({depthwiseConv2d_:function(t,e,n,r,o="NHWC",s=[1,1],i){const a=lo(t,"x","depthwiseConv2d"),u=lo(e,"filter","depthwiseConv2d");let c=a,l=!1;3===a.rank&&(l=!0,c=wi(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(4===c.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`)),C(4===u.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`)),C(c.shape[3]===u.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),null!=i&&C(q(r),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`));const h={x:c,filter:u},d={strides:n,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},p=no.runKernel(ce,h,d);return l?wi(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});const Li=po({dilation2d_:function(t,e,n,r,o=[1,1],s="NHWC"){const i=lo(t,"x","dilation2d"),a=lo(e,"filter","dilation2d");C(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),C(3===a.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`)),C("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let u=i,c=!1;3===i.rank&&(u=wi(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0);const l={x:u,filter:a},h={strides:n,pad:r,dilations:o},d=no.runKernel(pe,l,h);return c?wi(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});function qi(t,e){const n=t.length,r=[];for(let o=0;o<n;o++){const s=n-1-o,i=t[s]||1;(e[e.length-1-o]||1)>1&&1===i&&r.unshift(s)}return r}function Oi(t,e){const n=[];for(let r=0;r<e.length;r++){const o=t[t.length-r-1],s=e.length-r-1,i=e[s];(null==o||1===o&&i>1)&&n.unshift(s)}return n}function Gi(t,e){const n=[],r=Math.max(t.length,e.length);for(let o=0;o<r;o++){let r=t[t.length-o-1];null==r&&(r=1);let s=e[e.length-o-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`)}n.unshift(r)}}return n}const Ui=po({equal_:function(t,e){let n=lo(t,"a","equal"),r=lo(e,"b","equal");[n,r]=Jr(n,r),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(be,o)}});const Wi=po({where_:function(t,e,n){const r=lo(e,"a","where"),o=lo(n,"b","where"),s=lo(t,"condition","where","bool"),i=Gi(r.shape,o.shape),a=$i(r,i),u=$i(o,i);1===s.rank&&C(s.shape[0]===r.shape[0],(()=>"The first dimension of `a` must match the size of `condition`.")),1!==s.rank&&R(s.shape,u.shape,"Error in where: ");const c={condition:s,t:a,e:u};return no.runKernel(Rn,c)}});const Hi=po({zerosLike_:function(t){const e={x:lo(t,"x","zerosLike")};return no.runKernel(ur,e)}});const ji=po({divNoNan_:function(t,e){let n=lo(t,"a","div"),r=lo(e,"b","div");[n,r]=Jr(n,r);const o=Hs(n,r),s=Hi(o),i=Ui(r,s);return Wi(i,s,o)}});const Vi=po({dot_:function(t,e){const n=lo(t,"t1","dot"),r=lo(e,"t2","dot");C(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const o=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(C(o===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`)),1===n.rank&&1===r.rank){const t=wi(n,[1,-1]),e=wi(r,[-1,1]),o=ps(t,e);return wi(o,[])}if(1===n.rank&&2===r.rank){const t=wi(n,[1,-1]),e=wi(r,[r.shape[0],r.shape[1]]),o=ps(t,e);return wi(o,[o.size])}if(2===n.rank&&1===r.rank){const t=wi(r,[-1,1]),e=ps(n,t);return wi(e,[e.size])}{const t=wi(r,[r.shape[0],r.shape[1]]);return ps(n,t)}}});const Ji=po({elu_:function(t){const e={x:lo(t,"x","elu")};return no.runKernel(ge,e)}});const Xi=po({erf_:function(t){let e=lo(t,"x","erf");C("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=hs(e,"float32"));const n={x:e};return no.runKernel(ye,n)}});const Yi=po({exp_:function(t){const e={x:lo(t,"x","exp")};return no.runKernel(we,e)}});const Zi=po({expandDims_:function(t,e=0){const n=lo(t,"x","expandDims","string_or_numeric");C(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},o={dim:e};return no.runKernel(ke,r,o)}});const Qi=po({expm1_:function(t){const e={x:lo(t,"x","expm1")};return no.runKernel(xe,e)}});const ta=po({tile_:function(t,e){const n=lo(t,"x","tile","string_or_numeric");C(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const r={x:n},o={reps:e};return no.runKernel(nr,r,o)}});const ea=po({floor_:function(t){const e={x:lo(t,"x","floor")};return no.runKernel(Ee,e)}});const na=po({gather_:function(t,e,n=0,r=0){const o={x:lo(t,"x","gather"),indices:lo(e,"indices","gather","int32")},s={axis:n,batchDims:r};return no.runKernel(Ne,o,s)}});const ra=po({greater_:function(t,e){let n=lo(t,"a","greater"),r=lo(e,"b","greater");[n,r]=Jr(n,r),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(Fe,o)}});const oa=po({greaterEqual_:function(t,e){let n=lo(t,"a","greaterEqual"),r=lo(e,"b","greaterEqual");[n,r]=Jr(n,r),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(Ae,o)}});const sa=po({imag_:function(t){const e={input:lo(t,"input","imag")};return no.runKernel(Be,e)}});const ia=po({isFinite_:function(t){const e={x:lo(t,"x","isFinite")};return no.runKernel(Ce,e)}});const aa=po({isInf_:function(t){const e={x:lo(t,"x","isInf")};return no.runKernel(Re,e)}});const ua=po({isNaN_:function(t){const e={x:lo(t,"x","isNaN")};return no.runKernel(Pe,e)}});const ca=po({leakyRelu_:function(t,e=.2){const n={x:lo(t,"x","leakyRelu")},r={alpha:e};return no.runKernel(Ke,n,r)}});const la=po({less_:function(t,e){let n=lo(t,"a","less"),r=lo(e,"b","less");[n,r]=Jr(n,r),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(ze,o)}});const ha=po({lessEqual_:function(t,e){let n=lo(t,"a","lessEqual"),r=lo(e,"b","lessEqual");[n,r]=Jr(n,r),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(Le,o)}});const da=po({localResponseNormalization_:function(t,e=5,n=1,r=1,o=.5){const s=lo(t,"x","localResponseNormalization");C(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),C(q(e),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`));let i=s,a=!1;3===s.rank&&(a=!0,i=wi(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={x:i},c={depthRadius:e,bias:n,alpha:r,beta:o},l=no.runKernel(je,u,c);return a?wi(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const pa=po({log_:function(t){const e={x:lo(t,"x","log")};return no.runKernel(Oe,e)}});const fa=po({log1p_:function(t){const e={x:lo(t,"x","log1p")};return no.runKernel(Ge,e)}});function ga(t,e){C(it(t),(()=>"The f passed in variableGrads(f) must be a function")),C(null==e||Array.isArray(e)&&e.every((t=>t instanceof Lr)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in no.registeredVariables)e.push(no.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,o=e.length;C((e=e.filter((t=>t.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`));const{value:s,grads:i}=no.gradients(t,e,null,!0);C(i.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),C(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const a={};return e.forEach(((t,e)=>{null!=i[e]&&(a[t.name]=i[e])})),null!=r&&r.forEach((t=>a[t.name]=null)),{value:s,grads:a}}function ma(t){return no.customGrad(t)}const ya=po({neg_:function(t){const e={x:lo(t,"x","neg")};return no.runKernel(ln,e)}});const ba=po({softplus_:function(t){const e={x:lo(t,"x","softplus")};return no.runKernel(Gn,e)}});const wa=po({logSigmoid_:function(t){const e=lo(t,"x","logSigmoid");return ma((t=>({value:ya(ba(ya(t))),gradFunc:e=>js(e,vi(ya(t)))})))(e)}});const ka=po({max_:function(t,e=null,n=!1){const r={x:lo(t,"x","max")},o={reductionIndices:e,keepDims:n};return no.runKernel(Je,r,o)}});const xa=po({sub_:function(t,e){let n=lo(t,"a","sub"),r=lo(e,"b","sub");[n,r]=Jr(n,r);const o={a:n,b:r};return no.runKernel(Yn,o)}});const va=po({sum_:function(t,e=null,n=!1){let r=lo(t,"x","sum");"bool"===r.dtype&&(r=hs(r,"int32"));const o={x:r},s={axis:e,keepDims:n};return no.runKernel(Wn,o,s)}});const Sa=po({logSoftmax_:function(t,e=-1){const n=lo(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return ma(((t,n)=>{const r=ka(t,e,!0),o=xa(t,r),s=xa(hs(o,"float32"),pa(va(Yi(o),e,!0)));n([s]);return{value:s,gradFunc:(t,n)=>{const[r]=n,o=Yi(r);return xa(t,js(va(t,e,!0),o))}}}))(n)}});function Ia(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function Ea(t,e,n){const r=t.length+e.length,o=[];let s=0,i=0;for(let a=0;a<r;a++)-1===n.indexOf(a)?o.push(t[s++]):o.push(e[i++]);return o}function Da(t,e){const n=[],r=t.length;for(let o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map((e=>t[e]))]}function $a(t,e){return Ea(t,e.map((t=>1)),e)}function Na(t,e,n){C(Ia(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function Ta(t,e){if(Ia(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function Fa(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function Aa(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const _a=po({logSumExp_:function(t,e=null,n=!1){const r=lo(t,"x","logSumExp"),o=H(e,r.shape),s=ka(r,o,!0),i=xa(r,s),a=Yi(i),u=va(a,o),c=pa(u),l=Us(wi(s,c.shape),c);if(n){const t=$a(l.shape,o);return wi(l,t)}return l}});const Ma=po({logicalAnd_:function(t,e){const n=lo(t,"a","logicalAnd","bool"),r=lo(e,"b","logicalAnd","bool");Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(Ue,o)}});const Ba=po({logicalNot_:function(t){const e={x:lo(t,"x","logicalNot","bool")};return no.runKernel(We,e)}});const Ca=po({logicalOr_:function(t,e){const n=lo(t,"a","logicalOr","bool"),r=lo(e,"b","logicalOr","bool");Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(He,o)}});const Ra=po({logicalXor_:function(t,e){const n=lo(t,"a","logicalXor","bool"),r=lo(e,"b","logicalXor","bool");return Gi(n.shape,r.shape),Ma(Ca(t,e),Ba(Ma(t,e)))}});const Pa=po({maxPool_:function(t,e,n,r,o){const s=lo(t,"x","maxPool");let i=s,a=!1;3===s.rank&&(a=!0,i=wi(s,[1,s.shape[0],s.shape[1],s.shape[2]])),C(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),C(yi(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),null!=o&&C(q(r),(()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`));const u={x:i},c={filterSize:e,strides:n,pad:r,dimRoundingMode:o},l=no.runKernel(Ye,u,c);return a?wi(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Ka=po({maximum_:function(t,e){let n=lo(t,"a","maximum"),r=lo(e,"b","maximum");[n,r]=Jr(n,r),"bool"===n.dtype&&(n=hs(n,"int32"),r=hs(r,"int32")),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(Xe,o)}});const za=po({mean_:function(t,e=null,n=!1){const r={x:lo(t,"x","mean")},o={axis:e,keepDims:n};return no.runKernel(nn,r,o)}});const La=po({min_:function(t,e=null,n=!1){const r={x:lo(t,"x","min")},o={axis:e,keepDims:n};return no.runKernel(rn,r,o)}});const qa=po({minimum_:function(t,e){let n=lo(t,"a","minimum"),r=lo(e,"b","minimum");[n,r]=Jr(n,r),"bool"===n.dtype&&(n=hs(n,"int32"),r=hs(r,"int32")),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(on,o)}});const Oa=po({mirrorPad_:function(t,e,n){C("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=lo(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");C(e.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`));const o="reflect"===n?1:0;for(let t=0;t<r.rank;t++)C(2===e[t].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),C(e[t][0]>=0&&e[t][0]<=r.shape[t]-o&&e[t][1]>=0&&e[t][1]<=r.shape[t]-o,(()=>`Padding in dimension ${t} cannot be greater than or equal to ${r.shape[t]-o} or less than 0 for input of shape ${r.shape}`));const s={paddings:e,mode:n},i={x:r};return no.runKernel(sn,i,s)}});const Ga=po({mod_:function(t,e){let n=lo(t,"a","mod"),r=lo(e,"b","mod");[n,r]=Jr(n,r);const o={a:n,b:r};return no.runKernel(an,o)}});const Ua=po({square_:function(t){const e=lo(t,"x","square");return no.runKernel("Square",{x:e},{})}});const Wa=po({notEqual_:function(t,e){let n=lo(t,"a","notEqual"),r=lo(e,"b","notEqual");[n,r]=Jr(n,r),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(hn,o)}});function Ha(t,e="float32"){if("complex64"===e){const e=Ha(t,"float32"),n=Ha(t,"float32");return fo(e,n)}const n=dt(z(t),e);return no.makeTensor(n,t,e)}function ja(t,e="float32"){if("complex64"===e){const e=ja(t,"float32"),n=Ha(t,"float32");return fo(e,n)}const n=ht(z(t),e);return no.makeTensor(n,t,e)}const Va=po({onesLike_:function(t){const e={x:lo(t,"x","onesLike")};return no.runKernel(gn,e)}});const Ja=po({pad_:function(t,e,n=0){const r=lo(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:e,constantValue:n},s={x:r};return no.runKernel(bn,s,o)}});const Xa=po({spaceToBatchND_:function(t,e,n){const r=lo(t,"x","spaceToBatchND");C(r.rank>=1+e.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`)),C(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),C(r.shape.reduce(((t,r,o)=>o>0&&o<=e.length?t&&(r+n[o-1][0]+n[o-1][1])%e[o-1]==0:t),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const o={x:r},s={blockShape:e,paddings:n};return no.runKernel(Hn,o,s)}});const Ya=po({pool_:function(t,e,n,r,o,s){null==o&&(o=[1,1]),null==s&&(s=1),0===r&&(r="valid");const i=lo(t,"x","maxPool");let a=i,u=!1;3===i.rank&&(u=!0,a=wi(i,[1,i.shape[0],i.shape[1],i.shape[2]])),C(yi(s,o),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`));const c=ai(a.shape,e,s,o,r),l=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))).map((t=>t-1)),r=n.map((t=>Math.floor(t/2))),o=n.map(((t,e)=>t-r[e]));return n.map(((t,e)=>[r[e],o[e]]))}([c.filterHeight,c.filterWidth],l):[[0,0],[0,0]];const d=1===l[0]&&1===l[1],[p,f]=function(t,e,n){const r=n.map((t=>t[0])),o=n.map((t=>t[1])),s=t.concat(r,o),i=e.map(((t,e)=>(t-s[e]%t)%t)),a=o.map(((t,e)=>t+i[e])),u=e.map(((t,e)=>[r[e],a[e]])),c=e.map(((t,e)=>[0,i[e]]));return[u,c]}([c.inHeight,c.inWidth],l,h),g=d?r:"valid",m=d?a:Xa(a,l,p),y=("avg"===n?()=>ki(m,e,s,g):()=>Pa(m,e,s,g))(),b=d?y:Ei(y,l,f);return u?wi(b,[b.shape[1],b.shape[2],b.shape[3]]):b}});const Za=po({pow_:function(t,e){let n=lo(t,"base","pow"),r=lo(e,"exp","pow");[n,r]=Jr(n,r);const o={a:n,b:r};return no.runKernel(wn,o)}});const Qa=po({prelu_:function(t,e){const n={x:lo(t,"x","prelu"),alpha:lo(e,"alpha","prelu")};return no.runKernel(kn,n)}});const tu=po({prod_:function(t,e=null,n=!1){let r=lo(t,"x","prod");"bool"===r.dtype&&(r=hs(r,"int32"));const o={x:r},s={axis:e,keepDims:n};return no.runKernel(xn,o,s)}});const eu=po({real_:function(t){const e={input:lo(t,"input","real")};return no.runKernel(Sn,e)}});const nu=po({reciprocal_:function(t){const e={x:lo(t,"x","reciprocal")};return no.runKernel(In,e)}});const ru=po({relu_:function(t){const e={x:lo(t,"x","relu")};return no.runKernel(En,e)}});const ou=po({relu6_:function(t){const e={x:lo(t,"x","relu6")};return no.runKernel(An,e)}});const su=po({reverse_:function(t,e){const n={x:lo(t,"x","reverse")},r={dims:e};return no.runKernel(_n,n,r)}});const iu=po({round_:function(t){const e={x:lo(t,"x","round")};return no.runKernel(Mn,e)}});const au=po({rsqrt_:function(t){const e={x:lo(t,"x","rsqrt")};return no.runKernel(Bn,e)}});function uu(t,e){if((Q(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&Q(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return go(t,[],[],e)}const cu=po({selu_:function(t){const e={x:lo(t,"x","selu")};return no.runKernel(Pn,e)}});const lu=po({separableConv2d_:function(t,e,n,r,o,s=[1,1],i="NHWC"){const a=lo(t,"x","separableConv2d"),u=lo(e,"depthwiseFilter","separableConv2d"),c=lo(n,"pointwiseFilter","separableConv2d");let l=a,h=!1;if(3===a.rank&&(h=!0,l=wi(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");C(4===l.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`)),C(4===u.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`)),C(4===c.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`)),C(1===c.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`)),C(1===c.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`));const d=u.shape[2],p=u.shape[3];C(c.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`));const f=zi(l,u,r,o,i,s),g=Fi(f,c,1,"valid",i);return h?wi(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const hu=po({sign_:function(t){const e={x:lo(t,"x","sign")};return no.runKernel(qn,e)}});const du=po({sin_:function(t){const e={x:lo(t,"x","sin")};return no.runKernel(zn,e)}});const pu=po({sinh_:function(t){const e={x:lo(t,"x","sinh")};return no.runKernel(Ln,e)}});const fu=po({softmax_:function(t,e=-1){const n=lo(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},o={dim:e};return no.runKernel(Vn,r,o)}});const gu=po({fft_:function(t){C("complex64"===t.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`));const e={input:t};return no.runKernel(ve,e)}});const mu=po({ifft_:function(t){C("complex64"===t.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`));const e={input:t};return no.runKernel(Me,e)}});const yu=po({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const o=wi(t,[n,e]);r=mu(o)}else{const o=[n,2*(e-1)],s=wi(eu(t),[n,e]),i=wi(sa(t),[n,e]),a=su(Si(s,[0,1],[n,e-2]),1),u=js(su(Si(i,[0,1],[n,e-2]),1),uu(-1)),c=xi([s,a],1),l=xi([i,u],1),h=wi(fo(c,l),[o[0],o[1]]);r=mu(h)}if(r=eu(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=wi(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}});const bu=po({split_:function(t,e,n=0){const r={x:lo(t,"x","split")},o={numOrSizeSplits:e,axis:n};return no.runKernel(jn,r,o)}});const wu=po({rfft_:function(t,e){C("float32"===t.dtype,(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let n=t.shape[t.shape.length-1];const r=t.size/n;let o;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,o=Si(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,o=xi([t,Ha(r)],t.shape.length-1),n=e}else o=t;const s=Hi(o),i=wi(fo(o,s),[r,n]),a=gu(i),u=Math.floor(n/2)+1,c=eu(a),l=sa(a),h=bu(c,[u,n-u],c.shape.length-1),d=bu(l,[u,n-u],l.shape.length-1),p=o.shape.slice();return p[o.shape.length-1]=u,wi(fo(h[0],d[0]),p)}});const ku=po({sqrt_:function(t){const e={x:lo(t,"x","sqrt")};return no.runKernel(Un,e)}});const xu=po({squaredDifference_:function(t,e){let n=lo(t,"a","squaredDifference"),r=lo(e,"b","squaredDifference");[n,r]=Jr(n,r),Gi(n.shape,r.shape);const o={a:n,b:r};return no.runKernel(Jn,o,{})}});const vu=po({squeeze_:function(t,e){const n=lo(t,"x","squeeze");return wi(n,j(n.shape,e).newShape)}});const Su=po({stack_:function(t,e=0){const n=ho(t,"tensors","stack","string_or_numeric");C(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&C(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,o={axis:e};return no.runKernel(yn,r,o)}});const Iu=po({step_:function(t,e=0){const n={x:lo(t,"x","step")},r={alpha:e};return no.runKernel(cr,n,r)}});const Eu=po({stridedSlice_:function(t,e,n,r,o=0,s=0,i=0,a=0,u=0){const c={x:lo(t,"x","stridedSlice")},l={begin:e,end:n,strides:r,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return no.runKernel(Qn,c,l)}});const Du=po({tan_:function(t){const e={x:lo(t,"x","tan")};return no.runKernel(tr,e)}});const $u=po({topk_:function(t,e=1,n=!0){const r=lo(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const o=r.shape[r.shape.length-1];if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);const s={x:r},i={k:e,sorted:n},[a,u]=no.runKernel(rr,s,i);return{values:a,indices:u}}});const Nu=po({unique_:function(t,e=0){const n=lo(t,"x","unique","string_or_numeric");C(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},o={axis:e},[s,i]=no.runKernel(sr,r,o);return{values:s,indices:i}}});const Tu=po({unsortedSegmentSum_:function(t,e,n){const r=lo(t,"x","unsortedSegmentSum"),o=lo(e,"segmentIds","unsortedSegmentSum","int32");C(q(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:o},i={numSegments:n};return no.runKernel(ar,s,i)}});const Fu=po({unstack_:function(t,e=0){const n=lo(t,"x","unstack","string_or_numeric");C(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},o={axis:e};return no.runKernel(ir,r,o)}});function Au(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const r=ls(t,"int32"),o=ls([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const s=r.indexToLoc(n[e]),i=e*t.length;o.values.set(s,i)}return o.toTensor()}const _u=po({equalStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","equalStrict"),r=lo(e,"b","equalStrict");return R(n.shape,r.shape,"Error in equalStrict: "),Ui(n,r)}}),Mu=po({greaterEqualStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","greaterEqualStrict"),r=lo(e,"b","greaterEqualStrict");return R(n.shape,r.shape,"Error in greaterEqualStrict: "),oa(n,r)}}),Bu=po({greaterStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","greaterStrict"),r=lo(e,"b","greaterStrict");return R(n.shape,r.shape,"Error in greaterStrict: "),ra(n,r)}}),Cu=po({lessEqualStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","lessEqualStrict"),r=lo(e,"b","lessEqualStrict");return R(n.shape,r.shape,"Error in lessEqualStrict: "),ha(n,r)}}),Ru=po({lessStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","lessStrict"),r=lo(e,"b","lessStrict");return R(n.shape,r.shape,"Error in lessStrict: "),la(n,r)}}),Pu=po({notEqualStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","notEqualStrict"),r=lo(e,"b","notEqualStrict");return R(n.shape,r.shape,"Error in notEqualStrict: "),Wa(n,r)}});const Ku=po({addStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","addStrict"),r=lo(e,"b","addStrict");return R(n.shape,r.shape,"Error in addStrict: "),Us(n,r)}}),zu=po({divStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","div"),r=lo(e,"b","div");return R(n.shape,r.shape,"Error in divideStrict: "),Hs(n,r)}}),Lu=po({maximumStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","maximumStrict"),r=lo(e,"b","maximumStrict");return R(n.shape,r.shape,"Error in maximumStrict: "),Ka(n,r)}}),qu=po({minimumStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","minimumStrict"),r=lo(e,"b","minimumStrict");return R(n.shape,r.shape,"Error in minimumStrict: "),qa(n,r)}}),Ou=po({modStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","modStrict"),r=lo(e,"b","modStrict");return R(n.shape,r.shape,"Error in modStrict: "),Ga(n,r)}}),Gu=po({mulStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","mul"),r=lo(e,"b","mul");return R(n.shape,r.shape,"Error in multiplyStrict: "),js(n,r)}}),Uu=po({powStrict_:function(t,e){return Rs("strict variants of ops have been deprecated and will be removed in future"),R(t.shape,e.shape,"Error in powStrict: "),Za(t,e)}}),Wu=po({squaredDifferenceStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","squaredDifferenceStrict"),r=lo(e,"b","squaredDifferenceStrict");return R(n.shape,r.shape,"Error in squaredDifferenceStrict: "),xu(n,r)}}),Hu=po({subStrict_:function(t,e){Rs("strict variants of ops have been deprecated and will be removed in future");const n=lo(t,"a","subStrict"),r=lo(e,"b","subStrict");return R(n.shape,r.shape,"Error in subStrict: "),xa(n,r)}});function ju(t,e,n=null){if(0===t.rank)return Vs(t);if(1!==t.rank&&null===n)return ju(wi(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return va(Vs(t),n);if(e===1/0)return ka(Vs(t),n);if(e===-1/0)return La(Vs(t),n);if("euclidean"===e||2===e)return ku(va(Za(Vs(t),uu(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return ka(va(Vs(t),n[0]),n[1]-1);if(e===1/0)return ka(va(Vs(t),n[1]),n[0]);if(e===-1/0)return La(va(Vs(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return ku(va(Ua(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Vu=po({norm_:function(t,e="euclidean",n=null,r=!1){const o=ju(t=lo(t,"x","norm"),e,n);let s=o.shape;if(r){const e=H(n,t.shape);s=$a(o.shape,e)}return wi(o,s)}});const Ju=po({conv2DBackpropFilter_:function(t,e,n,r,o,s="NHWC",i){let a=t;3===t.rank&&(a=wi(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;3===u.rank&&(u=wi(e,[1,e.shape[0],e.shape[1],e.shape[2]])),C(4===a.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`)),C(4===u.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)),C(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const c="NHWC"===s?a.shape[3]:a.shape[1],l="NHWC"===s?u.shape[3]:u.shape[1];C(c===n[2],(()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`)),C(l===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`)),null!=i&&C(q(o),(()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${o}.`));const h={x:a,dy:u},d={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:n};return no.runKernel(Zt,h,d)}});function Xu(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return js(t,Iu(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Yu(t,e){let n=e;const r=Oi(t.shape,e.shape);return r.length>0&&(n=va(n,r)),wi(n,t.shape)}function Zu(t,e,n,r){if("linear"===e)return t;if("relu"===e)return ru(t);if("elu"===e)return Ji(t);if("relu6"===e)return ou(t);if("prelu"===e)return Qa(t,n);if("leakyrelu"===e)return ca(t,r);throw new Error(`Unknown fused activation ${e}.`)}const Qu=(t,e)=>!(t>0)||"linear"===e;const tc=po({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,o,s=[1,1],i){let a=t;3===t.rank&&(a=wi(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;3===u.rank&&(u=wi(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:u},l={strides:r,pad:o,dimRoundingMode:i,dilations:s,filterShape:n};return no.runKernel(le,c,l)}});const ec=po({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,o,s=[1,1],i){let a=e,u=!1;3===e.rank&&(u=!0,a=wi(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:n},l={strides:r,pad:o,dimRoundingMode:i,dilations:s,inputShape:t},h=no.runKernel(he,c,l);return u?wi(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});function nc(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,o=t.length,s=0,i=!1;for(;r<o;){s=r+(o-r>>>1);const a=n(e,t[s]);a>0?r=s+1:(o=s,i=!a)}return i?r:-r-1}(t,e,n||rc)}(t,e,n),o=r<0?-(r+1):r;t.splice(o,0,e)}function rc(t,e){return t>e?1:t<e?-1:0}function oc(t,e,n,r,o){return ac(t,e,n,r,o,0)}function sc(t,e,n,r,o,s){return ac(t,e,n,r,o,0,!1,s,!0)}function ic(t,e,n,r,o,s){return ac(t,e,n,r,o,s,!0)}function ac(t,e,n,r,o,s,i=!1,a=!1,u=!1){const c=[];for(let t=0;t<e.length;t++)e[t]>o&&c.push({score:e[t],boxIndex:t,suppressBeginIndex:0});c.sort(lc);const l=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){const e=c.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=e;if(n<o)break;let a=!1;for(let n=h.length-1;n>=i;--n){const i=uc(t,s,h[n]);if(i>=r){a=!0;break}if(e.score=e.score*cc(r,l,i),e.score<=o)break}e.suppressBeginIndex=h.length,a||(e.score===n?(h.push(s),d.push(e.score)):e.score>o&&nc(c,e,lc))}const p=h.length,f=n-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return i&&(g.selectedScores=d),u&&(g.validOutputs=p),g}function uc(t,e,n){const r=t.subarray(4*e,4*e+4),o=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(o[0],o[2]),l=Math.min(o[1],o[3]),h=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),p=(a-s)*(u-i),f=(h-c)*(d-l);if(p<=0||f<=0)return 0;const g=Math.max(s,c),m=Math.max(i,l),y=Math.min(a,h),b=Math.min(u,d),w=Math.max(y-g,0)*Math.max(b-m,0);return w/(p+f-w)}function cc(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function lc(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const hc=po({resizeBilinear_:function(t,e,n=!1,r=!1){const o=lo(t,"images","resizeBilinear");C(3===o.rank||4===o.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`)),C(2===e.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`)),C(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=o,i=!1;3===o.rank&&(i=!0,s=wi(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const a={images:s},u={alignCorners:n,halfPixelCenters:r,size:e},c=no.runKernel(Tn,a,u);return i?wi(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const dc=po({resizeNearestNeighbor_:function(t,e,n=!1,r=!1){const o=lo(t,"images","resizeNearestNeighbor");C(3===o.rank||4===o.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`)),C(2===e.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`)),C("float32"===o.dtype||"int32"===o.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),C(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=o,i=!1;3===o.rank&&(i=!0,s=wi(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const a={images:s},u={alignCorners:n,halfPixelCenters:r,size:e},c=no.runKernel($n,a,u);return i?wi(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),pc=1.7580993408473768,fc=1.0507009873554805,gc={kernelName:It,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(t,Iu(hs(n,"float32"),-1))}}},mc={kernelName:Et,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=Ua(hs(n,"float32")),r=ku(xa(uu(1),e));return ya(Hs(t,r))}}}},yc={kernelName:Dt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=ku(xa(Ua(hs(n,"float32")),1));return Hs(t,e)}}}},bc={kernelName:$t,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=Gi(n.shape,r.shape);return{a:()=>{let e=t;const r=Oi(n.shape,o);return r.length>0&&(e=va(e,r)),wi(e,n.shape)},b:()=>{let e=t;const n=Oi(r.shape,o);return n.length>0&&(e=va(e,n)),wi(e,r.shape)}}}},wc={kernelName:Nt,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},kc={kernelName:At,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hi(n)}}},xc={kernelName:_t,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hi(n)}}},vc={kernelName:Mt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hs(t,ku(xa(uu(1),Ua(hs(n,"float32")))))}}},Sc={kernelName:Bt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=ku(Us(uu(1),Ua(hs(n,"float32"))));return Hs(t,e)}}}},Ic={kernelName:Pt,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=Gi(n.shape,r.shape);return{a:()=>{const e=Us(Ua(n),Ua(r));let s=js(t,Hs(r,e));const i=Oi(n.shape,o);return i.length>0&&(s=va(s,i)),wi(s,n.shape)},b:()=>{const e=Us(Ua(n),Ua(r));let s=ya(js(t,Hs(n,e)));const i=Oi(r.shape,o);return i.length>0&&(s=va(s,i)),wi(s,r.shape)}}}},Ec={kernelName:Ct,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hs(t,Us(Ua(hs(n,"float32")),1))}}},Dc={kernelName:Rt,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hs(t,xa(uu(1),Ua(hs(n,"float32"))))}}};const $c=po({avgPool3dGrad_:function(t,e,n,r,o=[1,1,1],s,i){const a=lo(t,"dy","avgPool3dGrad"),u=lo(e,"input","avgPool3dGrad");let c=a,l=u,h=!1;4===u.rank&&(h=!0,c=wi(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),l=wi(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),C(5===c.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),C(5===l.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`)),C(yi(r,o),(()=>`Error in avgPool3dGrad: Either strides or dilations must be 1. Got strides ${r} and dilations '${o}'`)),null!=i&&C(q(s),(()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`));const d={dy:c,input:l},p={filterSize:n,strides:r,dilations:o,pad:s,dimRoundingMode:i},f=no.runKernel(qt,d,p);return h?wi(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),Nc={kernelName:Lt,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:o,strides:s,dilations:i,pad:a,dimRoundingMode:u}=n,c=null==i?[1,1,1]:i;return{x:()=>$c(t,r,o,s,c,a,u)}}};const Tc=po({avgPoolGrad_:function(t,e,n,r,o){const s=lo(t,"dy","avgPoolGrad"),i=lo(e,"input","avgPoolGrad");C(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let a=i,u=s,c=!1;3===i.rank&&(c=!0,a=wi(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=wi(s,[1,s.shape[0],s.shape[1],s.shape[2]])),C(4===u.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`)),C(4===a.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`));const l={dy:u,input:a},h={filterSize:n,strides:r,pad:o},d=no.runKernel(zt,l,h);return c?wi(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Fc={kernelName:Kt,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:o,strides:s,pad:i}=n;return{x:()=>Tc(t,r,o,s,i)}}},Ac={kernelName:Ot,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,o]=e,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>ps(t,o,!1,!1),b:()=>ps(t,r,!0,!1)}:s&&!i?{a:()=>ps(o,t,!1,!0),b:()=>ps(r,t,!1,!1)}:{a:()=>ps(o,t,!0,!0),b:()=>ps(t,r,!0,!0)}:{a:()=>ps(t,o,!1,!0),b:()=>ps(r,t,!0,!1)}}},_c={kernelName:Gt,gradFunc:(t,e,n)=>{const{blockShape:r,crops:o}=n;return{x:()=>Xa(t,r,o)}}},Mc={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,o=r.inputShape,s=r.shape,i=Array.from(s);for(let t=o.length-1;t>=0;t--)if(o[t]===s[t])i[t]=1;else if(1!==o[t])throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);const a=[];for(let t=0;t<i.length;t++)i[t]>1&&a.push(t);return{x:()=>va(t,a,!0)}}},Bc={kernelName:Wt,gradFunc:t=>({x:()=>t.clone()})},Cc={kernelName:Ht,gradFunc:t=>({x:()=>Hi(t)})},Rc={kernelName:jt,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:o,clipValueMax:s}=n;return{x:()=>Wi(Ma(oa(r,o),ha(r,s)),t,Hi(t))}}},Pc={kernelName:Jt,inputsToSave:["x"],gradFunc:gc.gradFunc},Kc={kernelName:Xt,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:o}=n,s=H(o,e[0].shape)[0],i=r.map((t=>t[s]));return bu(t,i,s).map((t=>()=>t))}},zc={kernelName:Yt,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,o]=e,{dilations:s,strides:i,pad:a,dataFormat:u}=n;return C(mi(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>_i(r.shape,t,o,i,a,u),filter:()=>Ju(r,t,o.shape,i,a,u)}}},Lc={kernelName:Qt,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,o]=e,{strides:s,pad:i,dataFormat:a,dimRoundingMode:u}=n;return{dy:()=>Fi(t,o,s,i,a,1,u),filter:()=>Ju(t,r,o.shape,s,i,a,u)}}};const qc=po({conv3DBackpropFilter_:function(t,e,n,r,o){let s=t;4===t.rank&&(s=wi(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=e;4===i.rank&&(i=wi(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),C(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),C(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),C(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),C(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),C(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const a={x:s,dy:i},u={strides:r,pad:o,filterShape:n};return no.runKernel(ee,a,u)}}),Oc={kernelName:te,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:o,pad:s}=n;C(mi(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,a]=e;return{x:()=>Bi(i.shape,t,a,o,s),filter:()=>qc(i,t,a.shape,o,s)}}},Gc={kernelName:re,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(ya(du(hs(n,"float32"))),t)}}},Uc={kernelName:oe,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(pu(hs(n,"float32")),t)}}},Wc={kernelName:se,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:o,exclusive:s,reverse:i}=n;return{x:()=>{const e=Ta([o],r.rank);let n=Pi(t,o,s,!i);return null!=e&&(n=gs(n,e)),n}}}},Hc={kernelName:ce,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:o,pad:s,dimRoundingMode:i}=n,a=null==r?[1,1]:r;C(mi(a),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`));const[u,c]=e;return C(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`)),C(4===c.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`)),C(u.shape[3]===c.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`)),C(yi(o,a),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`)),null!=i&&C(q(s),(()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`)),{x:()=>ec(u.shape,t,c,o,s,r,i),filter:()=>tc(u,t,c.shape,o,s,r,i)}}},jc={kernelName:pe,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,o]=e,s={x:r,filter:o,dy:t},i={x:r,filter:o,dy:t};return{x:()=>no.runKernel("Dilation2DBackpropInput",s,n),filter:()=>no.runKernel("Dilation2DBackpropFilter",i,n)}}},Vc={kernelName:ge,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>no.runKernel(me,r)}}},Jc={kernelName:ye,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=js(Yi(ya(Ua(n))),2/Math.sqrt(Math.PI));return{x:()=>js(t,r)}}},Xc={kernelName:we,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(t,n)}}},Yc={kernelName:ke,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>wi(t,n.shape)}}},Zc={kernelName:xe,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(t,Yi(n))}}},Qc={kernelName:Ee,gradFunc:t=>({x:()=>Hi(t)})},tl={kernelName:De,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=Gi(n.shape,r.shape);return{a:()=>{const e=Hs(t,hs(r,"float32")),s=Oi(n.shape,o);return s.length>0?wi(va(e,s),n.shape):e},b:()=>{let e=js(t,hs(n,"float32"));const s=Oi(r.shape,o);s.length>0&&(e=wi(va(e,s),r.shape));const i=Ua(r);return ya(Hs(e,hs(i,"float32")))}}}},el={kernelName:$e,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[o,s,i,a]=e,u=null==a?uu(1):a,c=Oi(s.shape,o.shape),l=[];if(1===s.rank){for(let t=0;t<o.shape.length-1;++t)l.push(o.shape[t]);l.push(1)}const h=xa(o,s),d=js(t,u),p=au(Us(i,uu(r))),f=js(js(js(p,p),p),uu(-.5));return{x:()=>1===s.rank?wi(js(js(t,ta(wi(p,[1,1,1,s.shape[0]]),l)),u),o.shape):wi(js(js(t,p),u),o.shape),mean:()=>{let t=js(js(p,uu(-1)),d);return 1===s.rank&&(t=va(t,c)),wi(t,s.shape)},variance:()=>{let t=js(js(f,h),d);return 1===s.rank&&(t=va(t,c)),wi(t,s.shape)},scale:()=>{const e=js(h,p);let n=js(t,e);return 1===s.rank&&(n=va(n,c)),wi(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=va(e,c)),wi(e,s.shape)}}}},nl={kernelName:Ne,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,o]=e,{axis:s}=n,i=H(s,r.shape)[0];return{x:()=>{const e=r.shape,n=o.size,a=e.slice(0,i),u=a.length,c=e.slice(s,e.length).slice(1),l=c.length,h=rl(0,u),d=rl(u+1,u+1+l),p=ol([a,[n],c]),f=wi(t,p),g=wi(o,[n]),m=ol([[u],h,d]),y=gs(f,m);let b=Tu(y,g,r.shape[i]);const w=Fa(m);return b=gs(b,w),b},indices:()=>o}}};function rl(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function ol(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const sl={kernelName:Ae,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>Hi(n),b:()=>Hi(r)}}},il={kernelName:_e,gradFunc:t=>({x:()=>hs(t,"float32")})},al={kernelName:Ce,gradFunc:t=>({x:()=>Hi(t)})},ul={kernelName:Re,gradFunc:t=>({x:()=>Hi(t)})},cl={kernelName:Pe,gradFunc:t=>({x:()=>Hi(t)})},ll={kernelName:Ke,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:o}=n,s=ra(r,0);return{x:()=>Wi(s,t,js(t,o))}}},hl={kernelName:Ge,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hs(t,Us(n,1))}}},dl={kernelName:Oe,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hs(t,hs(n,"float32"))}}},pl={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:o}=n;return{logits:()=>{const e=Yi(r);return xa(t,js(va(t,o,!0),e))}}}};const fl=po({localResponseNormalizationBackprop_:function(t,e,n,r=5,o=1,s=1,i=.5){const a={x:t,y:e,dy:n},u={depthRadius:r,bias:o,alpha:s,beta:i};return no.runKernel(Ve,a,u)}}),gl={kernelName:je,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{depthRadius:s,bias:i,alpha:a,beta:u}=n;return{x:()=>fl(r,o,t,s,i,a,u)}}};function ml(t,e,n,r){return e.rank<n.rank&&(e=wi(e,$a(e.shape,r))),t.rank<n.rank&&(t=wi(t,$a(t.shape,r))),{x:()=>js(t,hs(Ui(n,e),t.dtype))}}const yl={kernelName:Je,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:o}=r,s=e[0],i=ml(t,e[1],s,H(o,s.shape));return{x:()=>i.x()}}},bl={kernelName:Xe,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>js(t,hs(oa(n,r),"float32")),b:()=>js(t,hs(la(n,r),"float32"))}}};const wl=po({maxPool3dGrad_:function(t,e,n,r,o,s=[1,1,1],i,a){const u=lo(t,"dy","maxPool3dGrad"),c=lo(e,"input","maxPool3dGrad"),l=lo(n,"output","maxPool3dGrad");let h=u,d=c,p=l,f=!1;4===c.rank&&(f=!0,h=wi(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=wi(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),p=wi(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),C(5===h.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`)),C(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),C(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),C(yi(o,s),(()=>`Error in maxPool3dGrad: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`)),null!=a&&C(q(i),(()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`));const g={dy:h,input:d,output:p},m={filterSize:r,strides:o,dilations:s,pad:i,dimRoundingMode:a},y=no.runKernel(tn,g,m);return f?wi(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),kl={kernelName:Qe,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{filterSize:s,strides:i,dilations:a,pad:u,dimRoundingMode:c}=n,l=null==a?[1,1,1]:a;return{x:()=>wl(t,r,o,s,i,l,u,c)}}};const xl=po({maxPoolGrad_:function(t,e,n,r,o,s,i){const a=lo(t,"dy","maxPoolGrad"),u=lo(e,"input","maxPoolGrad"),c=lo(n,"output","maxPoolGrad");C(u.rank===a.rank,(()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`)),C(4===a.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`)),C(4===u.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`)),null!=i&&C(q(s),(()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`));const l={dy:a,input:u,output:c},h={filterSize:r,strides:o,pad:s,dimRoundingMode:i};return no.runKernel(Ze,l,h)}}),vl={kernelName:bn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:o}=n,s=o.map((t=>t[0]));return{x:()=>Si(t,s,r.shape)}}},Sl={kernelName:Hn,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:o}=n;return{x:()=>Ei(t,r,o)}}},Il={kernelName:jn,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>xi(t,r)}}};const El=[gc,mc,yc,bc,wc,kc,xc,vc,Sc,Ic,Ec,Dc,Nc,Fc,Ac,_c,Mc,Bc,Cc,Rc,Pc,Kc,Lc,zc,Oc,Gc,Uc,Wc,Hc,jc,{kernelName:fe,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=Gi(n.shape,r.shape);return{a:()=>{const e=Hs(t,hs(r,"float32")),s=Oi(n.shape,o);return s.length>0?wi(va(e,s),n.shape):e},b:()=>{let e=js(t,hs(n,"float32"));const s=Oi(r.shape,o);s.length>0&&(e=wi(va(e,s),r.shape));const i=Ua(r);return ya(Hs(e,hs(i,"float32")))}}}},Vc,Jc,Xc,Yc,Zc,tl,Qc,el,nl,sl,il,al,ul,cl,ll,hl,dl,pl,gl,yl,yl,bl,kl,{kernelName:Ye,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,o]=e,{filterSize:s,strides:i,pad:a}=n;return{x:()=>xl(t,r,o,s,i,a)}}},{kernelName:nn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:o}=n,s=H(o,r.shape),i=z(Da(r.shape,s)[1]);return{x:()=>{const e=r.shape.slice();s.forEach((t=>{e[t]=1}));const n=wi(t,e);return Hs(js(n,ja(r.shape,"float32")),i)}}}},{kernelName:rn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:o}=r,[s,i]=e,a=ml(t,i,s,H(o,s.shape));return{x:()=>a.x()}}},{kernelName:on,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>js(t,hs(ha(n,r),"float32")),b:()=>js(t,hs(ra(n,r),"float32"))}}},{kernelName:sn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:o}=n,s=o.map((t=>t[0]));return{x:()=>Si(t,s,r.shape)}}},{kernelName:an,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=Gi(n.shape,r.shape);return{a:()=>{const e=Oi(n.shape,o);return e.length>0?wi(va(t,e),n.shape):t},b:()=>{const e=js(t,ya(ea(Hs(n,r)))),s=Oi(r.shape,o);return s.length>0?wi(va(e,s),r.shape):e}}}},{kernelName:cn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=Gi(n.shape,r.shape);return{a:()=>{const e=js(t,hs(r,"float32")),s=Oi(n.shape,o);return s.length>0?wi(va(e,s),n.shape):e},b:()=>{const e=js(t,hs(n,"float32")),s=Oi(r.shape,o);return s.length>0?wi(va(e,s),r.shape):e}}}},{kernelName:ln,gradFunc:t=>({x:()=>ya(t)})},{kernelName:mn,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Ha(n.shape,"float32")}}},{kernelName:gn,gradFunc:t=>({x:()=>Hi(t)})},{kernelName:yn,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return Fu(t,r).map((t=>()=>t))}},vl,vl,{kernelName:wn,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,o]=e,s=n,i=r,a=Gi(s.shape,i.shape);return{a:()=>{const e=hs(i,"float32");let n=js(t,js(e,Za(s,xa(e,uu(1)))));const r=Oi(s.shape,a);return r.length>0&&(n=va(n,r)),wi(n,s.shape)},b:()=>{const e=ra(s,0),n=Wi(e,pa(s),Hi(s));let r=js(t,js(o,n));const u=Oi(i.shape,a);return u.length>0&&(r=va(r,u)),wi(r,i.shape)}}}},{kernelName:kn,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,o=ra(n,0);return{x:()=>Wi(o,t,js(t,r)),alpha:()=>{let e=Wi(o,Hi(t),js(t,n));const s=Oi(r.shape,t.shape);return s.length>0&&(e=va(e,s)),wi(e,r.shape)}}}},{kernelName:In,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hs(t,ya(Ua(n)))}}},{kernelName:An,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=js(ha(n,6),Iu(n));return{x:()=>js(t,hs(r,"float32"))}}},{kernelName:En,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(t,hs(Iu(n),"float32"))}}},{kernelName:Dn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wi(t,n.shape)}}},{kernelName:Tn,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,o={dy:t,images:r};return{images:()=>no.runKernel(Fn,o,n)}}},{kernelName:$n,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,o={dy:t,images:r};return{images:()=>no.runKernel(Nn,o,n)}}},{kernelName:_n,gradFunc:(t,e,n)=>{const{dims:r}=n,o=H(r,t.shape);return{x:()=>su(t,o)}}},{kernelName:Mn,gradFunc:t=>({x:()=>Hi(t)})},{kernelName:Bn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ya(Hs(t,js(Za(n,1.5),2)))}}},{kernelName:Rn,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>hs(Hi(n),"float32"),t:()=>js(t,hs(n,t.dtype)),e:()=>js(t,hs(Ba(n),t.dtype))}}},{kernelName:Pn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=ra(n,uu(0)),r=uu(pc),o=uu(fc),s=js(t,o),i=js(js(t,r),Yi(hs(n,"float32")));return Wi(e,s,i)}}}},{kernelName:On,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(t,js(n,xa(uu(1),n)))}}},{kernelName:qn,gradFunc:t=>({x:()=>Hi(t)})},{kernelName:zn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(Ci(hs(n,"float32")),t)}}},{kernelName:Ln,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(Ri(hs(n,"float32")),t)}}},{kernelName:Kn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:o,size:s}=n,i=r.shape,[a,u]=Ms(r,o,s),c=[];for(let e=0;e<t.rank;e++)c.push([a[e],i[e]-a[e]-u[e]]);return{x:()=>Ja(t,c)}}},{kernelName:Vn,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:o}=n,s=js(t,r);return{logits:()=>xa(s,js(va(s,[o],true),r))}}},{kernelName:Gn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(t,vi(n))}}},Sl,Sl,Il,Il,{kernelName:Un,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hs(t,js(ku(hs(n,"float32")),2))}}},{kernelName:Jn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=uu(2);return{a:()=>js(t,js(o,xa(n,r))),b:()=>js(t,js(o,xa(r,n)))}}},{kernelName:Xn,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(t,js(hs(n,"float32"),2))}}},{kernelName:cr,gradFunc:t=>({x:()=>Hi(t)})},{kernelName:Yn,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,o=Gi(n.shape,r.shape);return{a:()=>{let e=t;const r=Oi(n.shape,o);return r.length>0&&(e=va(e,r)),wi(e,n.shape)},b:()=>{let e=t;const n=Oi(r.shape,o);return n.length>0&&(e=va(e,n)),wi(ya(e),r.shape)}}}},{kernelName:Wn,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,o=r.shape.slice(),{axis:s}=n;H(s,r.shape).forEach((t=>{o[t]=1}));const i=wi(t,o),a=js(i,ja(r.shape,"float32"));return{x:()=>a}}},{kernelName:tr,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Hs(t,Ua(Ci(n)))}}},{kernelName:er,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>js(xa(uu(1),Ua(n)),t)}}},{kernelName:nr,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:o}=n;return{x:()=>{let e=Hi(r);if(1===r.rank)for(let n=0;n<o[0];++n)e=Us(e,Si(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<o[0];++n)for(let s=0;s<o[1];++s)e=Us(e,Si(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<o[0];++n)for(let s=0;s<o[1];++s)for(let i=0;i<o[2];++i)e=Us(e,Si(t,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<o[0];++n)for(let s=0;s<o[1];++s)for(let i=0;i<o[2];++i)for(let a=0;a<o[3];++a)e=Us(e,Si(t,[n*r.shape[0],s*r.shape[1],i*r.shape[2],a*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:or,gradFunc:(t,e,n)=>{const r=n,{perm:o}=r,s=Fa(o);return{x:()=>gs(t,s)}}},{kernelName:ir,gradFunc:(t,e,n)=>{const r=n,{axis:o}=r;return{value:()=>Su(t,o)}}},{kernelName:ar,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=Ka(e,Hi(e)),r=na(t,n);let o=oa(e,uu(0,"int32"));const s=r.rank-o.rank;for(let t=0;t<s;++t)o=Zi(o,t+1);o=Ma(o,ja(r.shape,"bool"));const i=Hi(r);return Wi(o,r,i)}(t,n)}}},{kernelName:ur,gradFunc:t=>({x:()=>Hi(t)})}];for(const t of El)xr(t);zr.prototype.abs=function(){return this.throwIfDisposed(),Vs(this)},zr.prototype.acos=function(){return this.throwIfDisposed(),Js(this)},zr.prototype.acosh=function(){return this.throwIfDisposed(),Xs(this)},zr.prototype.addStrict=function(t){return this.throwIfDisposed(),Ku(this,t)},zr.prototype.add=function(t){return this.throwIfDisposed(),Us(this,t)},zr.prototype.all=function(t,e){return this.throwIfDisposed(),Ys(this,t,e)},zr.prototype.any=function(t,e){return this.throwIfDisposed(),Zs(this,t,e)},zr.prototype.argMax=function(t){return this.throwIfDisposed(),Qs(this,t)},zr.prototype.argMin=function(t){return this.throwIfDisposed(),ti(this,t)},zr.prototype.asScalar=function(){return this.throwIfDisposed(),C(1===this.size,(()=>"The array must have only 1 element.")),wi(this,[])},zr.prototype.asType=function(t){return this.throwIfDisposed(),hs(this,t)},zr.prototype.as1D=function(){return this.throwIfDisposed(),wi(this,[this.size])},zr.prototype.as2D=function(t,e){return this.throwIfDisposed(),wi(this,[t,e])},zr.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),wi(this,[t,e,n])},zr.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),wi(this,[t,e,n,r])},zr.prototype.as5D=function(t,e,n,r,o){return this.throwIfDisposed(),wi(this,[t,e,n,r,o])},zr.prototype.asin=function(){return this.throwIfDisposed(),ei(this)},zr.prototype.asinh=function(){return this.throwIfDisposed(),ni(this)},zr.prototype.atan=function(){return this.throwIfDisposed(),ri(this)},zr.prototype.atan2=function(t){return this.throwIfDisposed(),oi(this,t)},zr.prototype.atanh=function(){return this.throwIfDisposed(),si(this)},zr.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),ki(this,t,e,n,r)},zr.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),Ei(this,t,e)},zr.prototype.batchNorm=function(t,e,n,r,o){return this.throwIfDisposed(),Di(this,t,e,n,r,o)},zr.prototype.broadcastTo=function(t){return this.throwIfDisposed(),$i(this,t)},zr.prototype.cast=function(t){return this.throwIfDisposed(),hs(this,t)},zr.prototype.ceil=function(){return this.throwIfDisposed(),Ni(this)},zr.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Ti(this,t,e)},zr.prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof zr&&(t=[t]),xi([this,...t],e)},zr.prototype.conv1d=function(t,e,n,r,o,s){return this.throwIfDisposed(),Ai(this,t,e,n,r,o,s)},zr.prototype.conv2dTranspose=function(t,e,n,r,o){return this.throwIfDisposed(),Mi(this,t,e,n,r,o)},zr.prototype.conv2d=function(t,e,n,r,o,s){return this.throwIfDisposed(),Fi(this,t,e,n,r,o,s)},zr.prototype.cos=function(){return this.throwIfDisposed(),Ci(this)},zr.prototype.cosh=function(){return this.throwIfDisposed(),Ri(this)},zr.prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),Pi(this,t,e,n)},zr.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),Ki(this,t,e)},zr.prototype.depthwiseConv2D=function(t,e,n,r,o,s){return Rs("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),zi(this,t,e,n,r,o,s)},zr.prototype.depthwiseConv2d=function(t,e,n,r,o,s){return this.throwIfDisposed(),zi(this,t,e,n,r,o,s)},zr.prototype.dilation2d=function(t,e,n,r,o){return this.throwIfDisposed(),Li(this,t,e,n,r,o)},zr.prototype.divNoNan=function(t){return this.throwIfDisposed(),ji(this,t)},zr.prototype.divStrict=function(t){return this.throwIfDisposed(),zu(this,t)},zr.prototype.div=function(t){return this.throwIfDisposed(),Hs(this,t)},zr.prototype.dot=function(t){return this.throwIfDisposed(),Vi(this,t)},zr.prototype.elu=function(){return this.throwIfDisposed(),Ji(this)},zr.prototype.equalStrict=function(t){return this.throwIfDisposed(),_u(this,t)},zr.prototype.equal=function(t){return this.throwIfDisposed(),Ui(this,t)},zr.prototype.erf=function(){return this.throwIfDisposed(),Xi(this)},zr.prototype.exp=function(){return this.throwIfDisposed(),Yi(this)},zr.prototype.expandDims=function(t){return this.throwIfDisposed(),Zi(this,t)},zr.prototype.expm1=function(){return this.throwIfDisposed(),Qi(this)},zr.prototype.fft=function(){return this.throwIfDisposed(),gu(this)},zr.prototype.flatten=function(){return this.throwIfDisposed(),wi(this,[this.size])},zr.prototype.floor=function(){return this.throwIfDisposed(),ea(this)},zr.prototype.floorDiv=function(t){return this.throwIfDisposed(),Ws(this,t)},zr.prototype.gather=function(t,e){return this.throwIfDisposed(),na(this,t,e)},zr.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),Mu(this,t)},zr.prototype.greaterEqual=function(t){return this.throwIfDisposed(),oa(this,t)},zr.prototype.greaterStrict=function(t){return this.throwIfDisposed(),Bu(this,t)},zr.prototype.greater=function(t){return this.throwIfDisposed(),ra(this,t)},zr.prototype.ifft=function(){return this.throwIfDisposed(),mu(this)},zr.prototype.irfft=function(){return this.throwIfDisposed(),yu(this)},zr.prototype.isFinite=function(){return this.throwIfDisposed(),ia(this)},zr.prototype.isInf=function(){return this.throwIfDisposed(),aa(this)},zr.prototype.isNaN=function(){return this.throwIfDisposed(),ua(this)},zr.prototype.leakyRelu=function(t){return this.throwIfDisposed(),ca(this,t)},zr.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),Cu(this,t)},zr.prototype.lessEqual=function(t){return this.throwIfDisposed(),ha(this,t)},zr.prototype.lessStrict=function(t){return this.throwIfDisposed(),Ru(this,t)},zr.prototype.less=function(t){return this.throwIfDisposed(),la(this,t)},zr.prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),da(this,t,e,n,r)},zr.prototype.logSigmoid=function(){return this.throwIfDisposed(),wa(this)},zr.prototype.logSoftmax=function(t){return this.throwIfDisposed(),Sa(this,t)},zr.prototype.logSumExp=function(t,e){return this.throwIfDisposed(),_a(this,t,e)},zr.prototype.log=function(){return this.throwIfDisposed(),pa(this)},zr.prototype.log1p=function(){return this.throwIfDisposed(),fa(this)},zr.prototype.logicalAnd=function(t){return this.throwIfDisposed(),Ma(this,t)},zr.prototype.logicalNot=function(){return this.throwIfDisposed(),Ba(this)},zr.prototype.logicalOr=function(t){return this.throwIfDisposed(),Ca(this,t)},zr.prototype.logicalXor=function(t){return this.throwIfDisposed(),Ra(this,t)},zr.prototype.matMul=function(t,e,n){return this.throwIfDisposed(),ps(this,t,e,n)},zr.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),Pa(this,t,e,n,r)},zr.prototype.max=function(t,e){return this.throwIfDisposed(),ka(this,t,e)},zr.prototype.maximumStrict=function(t){return this.throwIfDisposed(),Lu(this,t)},zr.prototype.maximum=function(t){return this.throwIfDisposed(),Ka(this,t)},zr.prototype.mean=function(t,e){return this.throwIfDisposed(),za(this,t,e)},zr.prototype.min=function(t,e){return this.throwIfDisposed(),La(this,t,e)},zr.prototype.minimumStrict=function(t){return this.throwIfDisposed(),qu(this,t)},zr.prototype.minimum=function(t){return this.throwIfDisposed(),qa(this,t)},zr.prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),Oa(this,t,e)},zr.prototype.modStrict=function(t){return this.throwIfDisposed(),Ou(this,t)},zr.prototype.mod=function(t){return this.throwIfDisposed(),Ga(this,t)},zr.prototype.mulStrict=function(t){return this.throwIfDisposed(),Gu(this,t)},zr.prototype.mul=function(t){return this.throwIfDisposed(),js(this,t)},zr.prototype.neg=function(){return this.throwIfDisposed(),ya(this)},zr.prototype.norm=function(t,e,n){return this.throwIfDisposed(),Vu(this,t,e,n)},zr.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),Pu(this,t)},zr.prototype.notEqual=function(t){return this.throwIfDisposed(),Wa(this,t)},zr.prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),fs(this,t,e,n)},zr.prototype.onesLike=function(){return this.throwIfDisposed(),Va(this)},zr.prototype.pad=function(t,e){return this.throwIfDisposed(),Ja(this,t,e)},zr.prototype.pool=function(t,e,n,r,o){return this.throwIfDisposed(),Ya(this,t,e,n,r,o)},zr.prototype.powStrict=function(t){return this.throwIfDisposed(),Uu(this,t)},zr.prototype.pow=function(t){return this.throwIfDisposed(),Za(this,t)},zr.prototype.prelu=function(t){return this.throwIfDisposed(),Qa(this,t)},zr.prototype.prod=function(t,e){return this.throwIfDisposed(),tu(this,t,e)},zr.prototype.reciprocal=function(){return this.throwIfDisposed(),nu(this)},zr.prototype.relu=function(){return this.throwIfDisposed(),ru(this)},zr.prototype.relu6=function(){return this.throwIfDisposed(),ou(this)},zr.prototype.reshapeAs=function(t){return this.throwIfDisposed(),wi(this,t.shape)},zr.prototype.reshape=function(t){return this.throwIfDisposed(),wi(this,t)},zr.prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),hc(this,t,e,n)},zr.prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),dc(this,t,e,n)},zr.prototype.reverse=function(t){return this.throwIfDisposed(),su(this,t)},zr.prototype.rfft=function(){return this.throwIfDisposed(),wu(this)},zr.prototype.round=function(){return this.throwIfDisposed(),iu(this)},zr.prototype.rsqrt=function(){return this.throwIfDisposed(),au(this)},zr.prototype.selu=function(){return this.throwIfDisposed(),cu(this)},zr.prototype.separableConv2d=function(t,e,n,r,o,s){return this.throwIfDisposed(),lu(this,t,e,n,r,o,s)},zr.prototype.sigmoid=function(){return this.throwIfDisposed(),vi(this)},zr.prototype.sign=function(){return this.throwIfDisposed(),hu(this)},zr.prototype.sin=function(){return this.throwIfDisposed(),du(this)},zr.prototype.sinh=function(){return this.throwIfDisposed(),pu(this)},zr.prototype.slice=function(t,e){return this.throwIfDisposed(),Si(this,t,e)},zr.prototype.softmax=function(t){return this.throwIfDisposed(),fu(this,t)},zr.prototype.softplus=function(){return this.throwIfDisposed(),ba(this)},zr.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),Xa(this,t,e)},zr.prototype.split=function(t,e){return this.throwIfDisposed(),bu(this,t,e)},zr.prototype.sqrt=function(){return this.throwIfDisposed(),ku(this)},zr.prototype.square=function(){return this.throwIfDisposed(),Ua(this)},zr.prototype.squaredDifference=function(t){return this.throwIfDisposed(),xu(this,t)},zr.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),Wu(this,t)},zr.prototype.squeeze=function(t){return this.throwIfDisposed(),vu(this,t)},zr.prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof zr?[this,t]:[this,...t];return Su(n,e)},zr.prototype.step=function(t){return this.throwIfDisposed(),Iu(this,t)},zr.prototype.stridedSlice=function(t,e,n,r,o,s,i,a){return this.throwIfDisposed(),Eu(this,t,e,n,r,o,s,i,a)},zr.prototype.subStrict=function(t){return this.throwIfDisposed(),Hu(this,t)},zr.prototype.sub=function(t){return this.throwIfDisposed(),xa(this,t)},zr.prototype.sum=function(t,e){return this.throwIfDisposed(),va(this,t,e)},zr.prototype.tan=function(){return this.throwIfDisposed(),Du(this)},zr.prototype.tanh=function(){return this.throwIfDisposed(),Ii(this)},zr.prototype.tile=function(t){return this.throwIfDisposed(),ta(this,t)},zr.prototype.toBool=function(){return this.throwIfDisposed(),hs(this,"bool")},zr.prototype.toFloat=function(){return this.throwIfDisposed(),hs(this,"float32")},zr.prototype.toInt=function(){return this.throwIfDisposed(),hs(this,"int32")},zr.prototype.topk=function(t,e){return this.throwIfDisposed(),$u(this,t,e)},zr.prototype.transpose=function(t){return this.throwIfDisposed(),gs(this,t)},zr.prototype.unique=function(t){return this.throwIfDisposed(),Nu(this,t)},zr.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),Tu(this,t,e)},zr.prototype.unstack=function(t){return this.throwIfDisposed(),Fu(this,t)},zr.prototype.where=function(t,e){return this.throwIfDisposed(),Wi(t,this,e)},zr.prototype.zerosLike=function(){return this.throwIfDisposed(),Hi(this)}}).call(this,n(32),n(70).Buffer)}]]);